# Default values for cmk.
# This is a YAML-formatted file.
# Declare variables to be passed into your templates.

apiServer:
  image:
    command: "./bin/api-server"
    args: []

  # Enable the API-server deployment.
  deploy: true

tenantManager:
  image:
    command: "/bin/tenant-manager"
    args: []

  # Enable the tenant-manager deployment.
  deploy: true

  service:
    enabled: true

    # This sets the service type more information can be found here: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types
    type: ClusterIP
    # This sets the ports more information can be found here: https://kubernetes.io/docs/concepts/services-networking/service/#field-spec-ports
    ports:
      - port: 8081 # must match .Values.cmk.port
        protocol: TCP
        targetPort: http
        name: http

tenantManagerCLI:
  image:
    # We don't use /bin/tenant-manager-cli
    # A intention of tenant-manager-cli is to create a new shell session
    # later to perform tenant operations.
    # Sleeping allows us to enter a pod which doesn't crash.
    command: "/bin/tenant-manager-cli"
    args: ["--sleep"]

  # Enable the tenant-manager-cli deployment.
  deploy: true

  service:
    enabled: true

  extraContainers: []

  extraInitContainer: []

taskScheduler:
  image:
    command: "/bin/task-scheduler"
    args: []

  # Enable the task-scheduler deployment
  deploy: true

taskWorker:
  image:
    command: "/bin/task-worker"
    args: []

  # Enable the task-worker deployment
  deploy: true

# Override the "name" value, which is used to annotate some of
# the resources that are created by this Chart (using "app.kubernetes.io/name").
# +docs:property
nameOverride: ""

# Override the "fullname" value. This value is used as part of
# most of the names of the resources created by this Helm chart.
# +docs:property
fullnameOverride: ""

# This namespace allows you to define where the services are installed into.
# If not set then they use the namespace of the release.
# This is helpful when installing a chart dependency (sub chart).
namespace: ""

# This will set the replicaset count more information can be found here: https://kubernetes.io/docs/concepts/workloads/controllers/replicaset/
replicaCount: 1

# This sets the container image more information can be found here: https://kubernetes.io/docs/concepts/containers/images/
image:
  # The container registry to pull the image from.
  # For example:
  #   registry: kms.common.repositories.cloud.sap
  #   repository: cmk
  # +docs:property
  registry: ""

  # The container image
  # +docs:property
  repository: cmk-api-server-dev

  # Override the image tag to deploy by setting this variable.
  # If no value is set, the chart's appVersion is used.
  # +docs:property
  tag: "latest"

  # Setting a digest will override any tag.
  # +docs:property
  # digest: sha256:0e072dddd1f7f8fc8909a2ca6f65e76c5f0d2fcfb8be47935ae3457e8bbceb20

  # Kubernetes imagePullPolicy.
  pullPolicy: IfNotPresent

  # Setting the arguments for the container
  # +docs:property
  #args:
  #  - --graceful-shutdown=2
  #  - --graceful-shutdown-message="Graceful shutdown in %d seconds"

  # Setting the command
  # +docs:property
  #command: "./extension-server"

# This is for the secretes for pulling an image from a private repository more information can be found here: https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/
imagePullSecrets: []
  #  - name: ""

# This section builds out the service account more information can be found here: https://kubernetes.io/docs/concepts/security/service-accounts/
serviceAccount:
  # Specifies whether a service account should be created
  create: true
  # Automatically mount a ServiceAccount's API credentials?
  automount: true
  # Annotations to add to the service account
  annotations: {}
  # The name of the service account to use.
  # If not set and create is true, a name is generated using the fullname template
  name: ""

# This is for setting Kubernetes Annotations to a Pod.
# For more information checkout: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/
podAnnotations: {}
# This is for setting Kubernetes Labels to a Pod.
# For more information checkout: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
podLabels: {}

podSecurityContext: {}
# fsGroup: 2000

securityContext: {}
  # capabilities:
  #   drop:
  #   - ALL
  # readOnlyRootFilesystem: true
  # runAsNonRoot: true
  # runAsUser: 1000

podDisruptionBudget:
  # Enable or disable the PodDisruptionBudget resource.
  #
  # This prevents downtime during voluntary disruptions such as during a Node upgrade.
  # For example, the PodDisruptionBudget will block `kubectl drain`
  # Pod is currently running.
  enabled: false

  # This configures the minimum available pods for disruptions. It can either be set to
  # an integer (e.g. 1) or a percentage value (e.g. 25%).
  # It cannot be used if `maxUnavailable` is set.
  # +docs:property
  # +docs:type=unknown
  # minAvailable: 1

  # This configures the maximum unavailable pods for disruptions. It can either be set to
  # an integer (e.g. 1) or a percentage value (e.g. 25%).
  # it cannot be used if `minAvailable` is set.
  # +docs:property
  # +docs:type=unknown
  # maxUnavailable: 1

# This is for setting up a service more information can be found here: https://kubernetes.io/docs/concepts/services-networking/service/
service:
  # Labels to add to the service
  labels: {}
  # Annotations to add to the service
  annotations: {}
  # This sets the service type more information can be found here: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types
  type: ClusterIP
  # This sets the ports more information can be found here: https://kubernetes.io/docs/concepts/services-networking/service/#field-spec-ports
  ports:
    - port: 8081 # must match .Values.cmk.port
      protocol: TCP
      targetPort: http
      name: http
    - port: 8888
      protocol: TCP
      targetPort: http-status
      name: http-status

resources: {}
  # We usually recommend not to specify default resources and to leave this as a conscious
  # choice for the user. This also increases chances charts run on environments with little
  # resources, such as Minikube. If you do want to specify resources, uncomment the following
  # lines, adjust them as necessary, and remove the curly braces after 'resources:'.
  # limits:
  #   cpu: 100m
  #   memory: 128Mi
  # requests:
  #   cpu: 100m
  #   memory: 128Mi

# This is to setup the liveness and readiness probes more information can be found here: https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/
livenessProbe:
  httpGet:
    path: /probe/liveness
    port: http-status
    scheme: HTTP
  failureThreshold: 1
  periodSeconds: 10
readinessProbe:
  httpGet:
    path: /probe/readiness
    port: http-status
    scheme: HTTP
  failureThreshold: 1
  periodSeconds: 10

# This section is for setting up autoscaling more information can be found here: https://kubernetes.io/docs/concepts/workloads/autoscaling/
autoscaling:
  enabled: false
  minReplicas: 1
  maxReplicas: 1
  targetCPUUtilizationPercentage: 80
  targetMemoryUtilizationPercentage: 80

# Additional init containers on the output Deployment definition.
extraInitContainers:
  - name: wait-for-postgresql
    image: busybox:1.35
    command:
      - sh
      - -c
      - |
        until nc -z cmk-postgresql 5432; do
          echo "Waiting for PostgreSQL..."
          sleep 3
        done

# Additional containers on the output Deployment definition.
extraContainers: []

# Additional volumes on the output Deployment definition.
extraVolumes:
  - name: cert-issuer-plugins
    projected:
      sources:
        - secret:
            name: cert-issuer-uaa
        - secret:
            name: cert-issuer-service
  - name: keystore-provider
    projected:
      sources:
        - secret:
            name: keystore-provider-hyperscaler
        - secret:
            name: keystore-provider-cert-service
        - secret:
            name: keystore-provider-iam
        - secret:
            name: keystore-provider-regions
  - name: cld-plugins
    secret:
      secretName: cld-uaa
  - name: uli-plugins
    secret:
      secretName: uli-keypair
  - name: event-processor
    secret:
      secretName: event-processor-credentials
  - name: identity-management
    secret:
      secretName: identity-management-credentials
  - name: notification-plugins
    projected:
      sources:
        - secret:
            name: notification-endpoints
        - secret:
            name: notification-uaa
  - name: signing-keys
    secret:
      secretName: signing-keys

# Additional volumeMounts on the output Deployment definition.
extraVolumeMounts:
  - name: keystore-provider
    mountPath: "/etc/credentials/keystore-plugins/management"
    readOnly: true
  - name: cert-issuer-plugins
    mountPath: "/etc/credentials/cert-issuer-plugins"
    readOnly: true
  - name: cld-plugins
    mountPath: "/etc/credentials/sis-plugins/cld"
    readOnly: true
  - name: uli-plugins
    mountPath: "/etc/credentials/sis-plugins/uli"
    readOnly: true
  - name: event-processor
    mountPath: "/etc/event-processor"
    readOnly: true
  - name: notification-plugins
    mountPath: "/etc/credentials/notification-plugins"
    readOnly: true
  - name: signing-keys
    mountPath: "/etc/signing-keys"
    readOnly: true

# Additional ens on the output Deployment definition.
extraEnvs:
  - name: AWS_KMS_HOST
    value: "localhost"
  - name: AWS_KMS_PORT
    value: "8081"

# Additional envsFrom on the output Deployment definition.
extraEnvsFrom: []

nodeSelector: {}

tolerations: []

ports:
  - name: http-status
    containerPort: 8888
    protocol: TCP
  - name: http
    containerPort: 8081
    protocol: TCP

affinity: {}

config:
  isImmutable: false

  # Environment where the application is running
  environment: dev
  # Labels associated to metrics, traces and logs
  labels: {}

  featureGates:
    enrich-header-with-client-type: true
    enrich-header-with-client-region: true
    disable-client-certificate-computation: false
    disable-jwt-token-computation: false

  http:
    port: 8081

  # Expose the status port
  status:
    enabled: true
    address: ":8888"
    profiling: false

  certificates:
    rootCertURL: https://aia.pki.co.example.com/aia/EXAMPLE%20Cloud%20Root%20CA.crt
    validityDays: 30
    rotationThresholdDays: 7

  cryptoLayer:
    certX509Trusts:
      source: embedded
      value: |
        {
          "crypto-1": {
            "Subject": "FakeCert",
            "RootCA": "https://aia.pki.co.example.com/aia/EXAMPLE%20Cloud%20Root%20CA.crt"
          }
        }

  # This does set the logger configuration
  # +docs:property
  logger:
    level: debug # one of: debug, info, warn, error
    # Format of the logs
    format: json # one of: json, text
    formatter:
      time:
        type: pattern # one of: pattern, unix
        # Used only when the property type: pattern
        # Should follow golang time pattern
        # Default value time.RFC3339.
        pattern: "Mon Jan 02 15:04:05 -0700 2006"
        # Used only when the property type: unix
        # Time units are "1ns", "1us" (or "1µs"), "1ms", "1s"
        # Default value 1s.
        precision: 1s
      fields:
        # Field names (this way the field name can be changed) to be used on log records; These are their defaults.
        error: "error"
        message: "msg"
        level: "level"
        time: "time"
        # Fields names used by OTEL to track the Trace and Span ID
        otel:
          traceID: "trace.id" # Default is TraceID
          spanID: "span.id" # Default is SpanID
        masking:
          # All fields under PII, the formatters will mask the value and keeping first 4 original characters
          pii:
            - email
            - ip-address
          # All fields under other, the formatters will mask the value, using given mask.
          other:
            jwt-token: "*****"
  telemetry:
    logs:
      enabled: false
      protocol: http # one of: http, grpc; Default is http
      # Host configuration example set as a value:
      # host:
      #   source: embedded
      #   value: localhost:4317
      # Host configuration example load value from an environment variable:
      # host:
      #   source: env
      #   env: OTEL_LOGS_HOST
      # Host configuration example load value from a JSON file:
      # host:
      #   source: file
      #   file:
      #     path: /etc/credentials/config.json
      #     format: json # one of: json
      #     jsonPath: "$.credentials.ingest-otlp-endpoint" # Syntax JSONPath Query Expression
      host:
        source: embedded
        value: localhost:4317
      url: /api/v2/otlp/v1/logs
      # OpenTelemetry secret connections; Applicable in the same way for logs, traces and metrics
      # Insecure configuration example:
      #   secretRef:
      #     type: insecure # one of: insecure, mtls, api-token
      # APIToken configuration example loading value from environment variable:
      #   secretRef:
      #     type: api-token # one of: insecure, mtls, api-token
      #     apiToken:
      #       source: env
      #       env: OTEL_LOS_API_TOKEN
      # APIToken configuration example loading value from binary file as is:
      #   secretRef:
      #     type: api-token # one of: insecure, mtls, api-token
      #     apiToken:
      #       source: file
      #       path: /etc/credentials/api-token
      #       format: binary # one of: json, binary
      # APIToken configuration example loading value from JSON file, extracting a specific field:
      #   secretRef:
      #     type: api-token # one of: insecure, mtls, api-token
      #     apiToken:
      #       source: file
      #       path: /etc/credentials/api-token.json
      #       format: json # one of: json, binary
      #       jsonPath: "$.credentials.api-token" # Syntax JSONPath Query Expression
      # mTLS configuration example loading value from environment variables:
      #   secretRef:
      #     type: mtls # one of: insecure, mtls, api-token
      #     mtls:
      #       cert:
      #         source: env
      #         env: OTEL_LOGS_X509_CERT
      #       certKey:
      #         source: env
      #         env: OTEL_LOGS_X509_CERT_KEY
      #       serverCA:
      #         source: env
      #         env: OTEL_LOGS_X509_SERVER_CA
      # mTLS configuration example loading value from binary file as is:
      #   secretRef:
      #     type: mtls # one of: insecure, mtls, api-token
      #     mtls:
      #       cert:
      #         source: file
      #         file:
      #           path: /etc/credentials/cert.pem
      #           format: binary # one of: json, binary
      #       certKey:
      #         source: file
      #         file:
      #           path: /etc/credentials/cert-key.pem
      #           format: binary # one of: json, binary
      #       serverCA:
      #         source: file
      #         file:
      #           path: /etc/credentials/server-ca.pem
      #           format: binary # one of: json, binary
      # mTLS configuration example loading value from JSON file, extracting a specific field:
      #   secretRef:
      #     type: mtls # one of: insecure, mtls, api-token
      #     mtls:
      #       cert:
      #         source: file
      #         file:
      #           path: /etc/credentials/config.json
      #           format: json # one of: json, binary
      #           jsonPath: "$.credentials.ingest-otlp-cert" # Syntax JSONPath Query Expression
      #       certKey:
      #         source: file
      #         file:
      #           path: /etc/credentials/config.json
      #           format: json # one of: json, binary
      #           jsonPath: "$.credentials.ingest-otlp-key" # Syntax JSONPath Query Expression
      #       serverCA:
      #         source: file
      #         file:
      #           path: /etc/credentials/config.json
      #           format: json # one of: json, binary
      #           jsonPath: "$.credentials.server-ca" # Syntax JSONPath Query Expression
      secretRef:
        type: api-token # one of: insecure, mtls, api-token
        apiToken:
          source: embedded
          value: "unknown"
    traces:
      enabled: false
      protocol: http # one of: http, grpc; Default is http
      # Host configuration example set as a value:
      # host:
      #   source: embedded
      #   value: localhost:4317
      # Host configuration example load value from an environment variable:
      # host:
      #   source: env
      #   env: OTEL_LOGS_HOST
      # Host configuration example load value from a JSON file:
      # host:
      #   source: file
      #   file:
      #     path: /etc/credentials/config.json
      #     format: json # one of: json
      #     jsonPath: "$.credentials.ingest-otlp-endpoint" # Syntax JSONPath Query Expression
      host:
        source: embedded
        value: localhost:4317
      url: /api/v2/otlp/v1/traces
      # OpenTelemetry traces secret; See examples from logs.
      secretRef:
        type: api-token # insecure, mtls, api-token
        apiToken:
          source: embedded
          value: "unknown"
    metrics:
      enabled: false
      protocol: http # one of: http, grpc; Default is http
      # Host configuration example set as a value:
      # host:
      #   value: localhost:4317
      # Host configuration example load value from an environment variable:
      # host:
      #   source: env
      #   env: OTEL_LOGS_HOST
      # Host configuration example load value from a JSON file:
      # host:
      #   source: file
      #   file:
      #     path: /etc/credentials/config.json
      #     format: json # one of: json
      #     jsonPath: "$.credentials.ingest-otlp-endpoint" # Syntax JSONPath Query Expression
      host:
        source: embedded
        value: localhost:4317
      url: /api/v2/otlp/v1/metrics
      # OpenTelemetry traces secret; See examples from logs.
      secretRef:
        type: api-token # insecure, mtls, api-token
        apiToken:
          source: embedded
          value: "unknown"
      # Metrics exposed through /metrics endpoint for prometheus
      prometheus:
        enabled: true

  # Database dependency configuration
  database:
    host:
      source: embedded
      value: cmk-postgresql.cmk.svc.cluster.local
    user:
      source: embedded
      value: postgres
    secret:
      source: embedded
      value: secret
    name: cmk
    port: 5432

  tenantManager:
    amqp:
      url: amqp://guest:guest@rabbitmq.cmk.svc.cluster.local:5672
      target: cmk.global.tenants
      source: cmk.emea.tenants

  scheduler:
    taskQueue:
      host:
        source: embedded
        value: cmk-redis-master.cmk.svc.cluster.local
      acl:
        username:
          source: embedded
          value: default
        password:
          source: embedded
          value: secret
        enabled: true
      port: 6379
      SecretRef:
        type: insecure # one of: insecure, mtls
    tasks:
      - cronspec: "@every 1h"
        taskType: sys:refresh
        retries: 3
      - cronspec: "@every 24h"
        taskType: cert:rotate
        retries: 3
      - cronspec: "@every 1h"
        taskType: key:sync
        retries: 3
      - cronspec: "@every 1h"
        taskType: keystore:fill
        retries: 3
  services:
    registry:
      enabled: true
      address: registry.default.svc.cluster.local:9092
      secretRef:
        type: insecure

  plugins:
    - name: AWS
      path: ./bin/awskeyop
      type: KeystoreInstanceKeyOperation
      logLevel: debug
      tags: ["hyok", "default_keystore"]
    - name: FORTANIX
      path: ./bin/fortanixkeyop
      type: KeystoreInstanceKeyOperation
      logLevel: debug
      tags: ["hyok"]
    - name: AWS
      path: ./bin/awskeymang
      logLevel: debug
      type: KeystoreProvider
      tags: ["keystore_provider"]
      yamlConfiguration: |
        hyperscaler:
          source: file
          file:
            path: /etc/credentials/keystore-plugins/management/hyperscaler.json
            format: binary
        certificateservice:
          source: file
          file:
            path: /etc/credentials/keystore-plugins/management/certificate-service.json
            format: binary
        iamserviceuser:
          source: file
          file:
            path: /etc/credentials/keystore-plugins/management/iam-service-user.json
            format: binary
        supportedregions:
          source: file
          file:
            path: /etc/credentials/keystore-plugins/management/supported-regions.json
            format: binary
    - name: SYSINFO
      path: ./bin/cld
      type: SystemInformationService
      logLevel: debug
      tags: ["cld"]
      yamlConfiguration: |
        cldisEndpoint:
          source: embedded
          value: https://vlab.cld.landscape.int.sap
        uaa:
          source: file
          file:
            path: /etc/credentials/sis-plugins/cld/uaa.json
            format: binary
    - name: SYSINFO
      path: ./bin/uli
      type: SystemInformationService
      logLevel: debug
      tags: ["uli"]
      yamlConfiguration: |
        uliEndpoint: https://ums.ums-stage.shoot.canary.k8s-hana.ondemand.com/graphql
        certificate:
          source: file
          file:
            path: /etc/credentials/sis-plugins/uli/cert.pem
            format: binary
        key:
          source: file
          file:
            path: /etc/credentials/sis-plugins/uli/key.pem
            format: binary
    - name: CERT_ISSUER
      path: ./bin/cert-issuer
      type: CertificateIssuerService
      logLevel: debug
      tags: ["cert_issuer"]
      yamlConfiguration: |
        certificateservice:
          source: file
          file:
            path: /etc/credentials/cert-issuer-plugins/service.json
            format: binary
        uaa:
          source: file
          file:
            path: /etc/credentials/cert-issuer-plugins/uaa.json
            format: binary
    - name: IDENTITY_MANAGEMENT
      path: ./bin/identity-management
      type: IdentityManagementService
      logLevel: debug
      tags: ["identity_management"]
      yamlConfiguration: |
        credentialfile: /etc/identity-management/identity-management.json
    - name: NOTIFICATION
      path: ./bin/notification
      type: NotificationService
      logLevel: debug
      yamlConfiguration: |
        Endpoints:
          source: file
          file:
            path: /etc/notification/endpoints.json
            format: binary
        UAA:
          source: file
          file:
            path: /etc/notification/uaa.json
            format: binary
  activePlugins:
    - hyok
    - default_keystore
    - uli
    - cert_issuer
    - keystore_provider

  system:
    identifier:
      displayName: "GTID"
      internal: true
    region:
      displayName: "Region"
      internal: true
    type:
      displayName: "Type"
      internal: true
    name:
      displayName: "Name"
      default: "n/a"
      optional: true
    systemrole:
      displayName: "Role"
      optional: true
    systemroleiD:
      displayName: "RoleID"
      optional: true

  provisioning:
    initKeystoreConfig:
      enabled: true
      provider: AWS
      value:
        localityId: 12345678-90ab-cdef-1234-567890abcdef
        commonName: example.kms.aws
        managementAccessData: |
          roleArn: arn:aws:iam::123456789012:role/KMSServiceRoleAnywhereRole
          trustAnchorArn: arn:aws:rolesanywhere:eu-west-2:123456789012:trust-anchor/12345678-90ab-cdef-1234-567890abcdef
          profileArn: arn:aws:rolesanywhere:eu-west-2:123456789012:profile/12345678-90ab-cdef-1234-567890abcdef
        supportedRegions:
          - name: Europe (Frankfurt)
            technicalName: eu-central-1
          - name: Europe (Ireland)
            technicalName: eu-west-1
          - name: Europe (London)
            technicalName: eu-west-2
          - name: United States (N. Virginia)
            technicalName: us-east-1
          - name: United States (Ohio)
            technicalName: us-east-2
  eventProcessor:
    secretRef:
      type: insecure
      mTLS:
        serverCA:
          source: file
          file:
            path: /etc/event-processor/secrets.json
            format: json
            jsonPath: "$.serverCA" # Syntax JSONPath Query Expression
        cert:
          source: file
          file:
            path: /etc/event-processor/secrets.json
            format: json
            jsonPath: "$.cert" # Syntax JSONPath Query Expression
        certKey:
          source: file
          file:
            path: /etc/event-processor/secrets.json
            format: json
            jsonPath: "$.certKey" # Syntax JSONPath Query Expression
    targets:
      - region: eu10
        amqp:
          url: "amqp://guest:guest@rabbitmq.cmk.svc.cluster.local:5672"
          target: "integration.eu10"
          source: "cmk.keys"
      - region: eu20
        amqp:
          url: "amqp://guest:guest@rabbitmq.cmk.svc.cluster.local:5672"
          target: "integration.eu20"
          source: "cmk.keys"
      - region: eu30
        amqp:
          url: "amqp://guest:guest@rabbitmq.cmk.svc.cluster.local:5672"
          target: "integration.eu30"
          source: "cmk.keys"
    maxReconcileCount: 18

  audit:
    endpoint: http://localhost:4043/logs
    additionalProperties: |
      specVersion: "v1"
      appID: "cmk"
      folderPath: "/var/log/cmk"
      accountID: "123456789012"
      resourceGroupPath: "/cmk"
      region: "eu10"
      appImage: "cmk:latest"
      appVersion: "1.0.0"

  clientData:
    signingKeysPath: /etc/signing-keys

  keystorePool:
    size: 2
    interval: 10m