//go:build go1.22

// Package cmkapi provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package cmkapi

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/oapi-codegen/runtime"
	strictnethttp "github.com/oapi-codegen/runtime/strictmiddleware/nethttp"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

// Defines values for GroupRole.
const (
	GroupRoleKEYADMINISTRATOR    GroupRole = "KEY_ADMINISTRATOR"
	GroupRoleTENANTADMINISTRATOR GroupRole = "TENANT_ADMINISTRATOR"
	GroupRoleTENANTAUDITOR       GroupRole = "TENANT_AUDITOR"
)

// Defines values for KeyAlgorithm.
const (
	KeyAlgorithmAES256  KeyAlgorithm = "AES256"
	KeyAlgorithmRSA3072 KeyAlgorithm = "RSA3072"
	KeyAlgorithmRSA4096 KeyAlgorithm = "RSA4096"
)

// Defines values for KeyState.
const (
	KeyStateDELETED         KeyState = "DELETED"
	KeyStateDETATCHED       KeyState = "DETATCHED"
	KeyStateDISABLED        KeyState = "DISABLED"
	KeyStateENABLED         KeyState = "ENABLED"
	KeyStateFORBIDDEN       KeyState = "FORBIDDEN"
	KeyStatePENDINGDELETION KeyState = "PENDING_DELETION"
	KeyStatePENDINGIMPORT   KeyState = "PENDING_IMPORT"
	KeyStateUNKNOWN         KeyState = "UNKNOWN"
)

// Defines values for KeyType.
const (
	KeyTypeBYOK          KeyType = "BYOK"
	KeyTypeHYOK          KeyType = "HYOK"
	KeyTypeSYSTEMMANAGED KeyType = "SYSTEM_MANAGED"
)

// Defines values for SystemStatus.
const (
	SystemStatusCONNECTED    SystemStatus = "CONNECTED"
	SystemStatusDISCONNECTED SystemStatus = "DISCONNECTED"
	SystemStatusFAILED       SystemStatus = "FAILED"
	SystemStatusPROCESSING   SystemStatus = "PROCESSING"
)

// Defines values for SystemRecoveryActionBodyAction.
const (
	SystemRecoveryActionBodyActionCANCEL SystemRecoveryActionBodyAction = "CANCEL"
	SystemRecoveryActionBodyActionRETRY  SystemRecoveryActionBodyAction = "RETRY"
)

// Defines values for WorkflowActionTypeEnum.
const (
	WorkflowActionTypeEnumLINK   WorkflowActionTypeEnum = "LINK"
	WorkflowActionTypeEnumSWITCH WorkflowActionTypeEnum = "SWITCH"
	WorkflowActionTypeEnumUNLINK WorkflowActionTypeEnum = "UNLINK"
)

// Defines values for WorkflowApproverDecision.
const (
	WorkflowApproverDecisionAPPROVED WorkflowApproverDecision = "APPROVED"
	WorkflowApproverDecisionPENDING  WorkflowApproverDecision = "PENDING"
	WorkflowApproverDecisionREJECTED WorkflowApproverDecision = "REJECTED"
)

// Defines values for WorkflowArtifactTypeEnum.
const (
	WorkflowArtifactTypeEnumSYSTEM WorkflowArtifactTypeEnum = "SYSTEM"
)

// Defines values for WorkflowParametersResourceTypeEnum.
const (
	WorkflowParametersResourceTypeEnumKEYCONFIGURATION WorkflowParametersResourceTypeEnum = "KEY_CONFIGURATION"
)

// Defines values for WorkflowStateEnum.
const (
	WorkflowStateEnumEXECUTING        WorkflowStateEnum = "EXECUTING"
	WorkflowStateEnumEXPIRED          WorkflowStateEnum = "EXPIRED"
	WorkflowStateEnumFAILED           WorkflowStateEnum = "FAILED"
	WorkflowStateEnumINITIAL          WorkflowStateEnum = "INITIAL"
	WorkflowStateEnumREJECTED         WorkflowStateEnum = "REJECTED"
	WorkflowStateEnumREVOKED          WorkflowStateEnum = "REVOKED"
	WorkflowStateEnumSUCCESSFUL       WorkflowStateEnum = "SUCCESSFUL"
	WorkflowStateEnumWAITAPPROVAL     WorkflowStateEnum = "WAIT_APPROVAL"
	WorkflowStateEnumWAITCONFIRMATION WorkflowStateEnum = "WAIT_CONFIRMATION"
)

// Defines values for WorkflowTransitionValue.
const (
	WorkflowTransitionValueAPPROVE WorkflowTransitionValue = "APPROVE"
	WorkflowTransitionValueCONFIRM WorkflowTransitionValue = "CONFIRM"
	WorkflowTransitionValueREJECT  WorkflowTransitionValue = "REJECT"
	WorkflowTransitionValueREVOKE  WorkflowTransitionValue = "REVOKE"
)

// Defines values for WrappingAlgorithmHashFunction.
const (
	WrappingAlgorithmHashFunctionSHA1   WrappingAlgorithmHashFunction = "SHA1"
	WrappingAlgorithmHashFunctionSHA256 WrappingAlgorithmHashFunction = "SHA256"
)

// Defines values for WrappingAlgorithmName.
const (
	WrappingAlgorithmNameCKMRSAAESKEYWRAP WrappingAlgorithmName = "CKM_RSA_AES_KEY_WRAP"
	WrappingAlgorithmNameCKMRSAPKCSOAEP   WrappingAlgorithmName = "CKM_RSA_PKCS_OAEP"
)

// ClientCertName The name of the crypto client using this Client Certificate
type ClientCertName = string

// ClientCertRootCA The root CA for the certificate
type ClientCertRootCA = string

// ClientCertSubject The subject of the certificate
type ClientCertSubject = string

// ClientCertificates defines model for ClientCertificates.
type ClientCertificates struct {
	Crypto        *CryptoCertificateList        `json:"crypto,omitempty"`
	TenantDefault *TenantDefaultCertificateList `json:"tenantDefault,omitempty"`
}

// CreatedAt The datetime of when the object was created (RFC3339 format)
type CreatedAt = time.Time

// CreatorID The ID of the User who created the object
type CreatorID = string

// CreatorName The username of the User who created the object
type CreatorName = string

// CryptoCertificate A Crypto Certificate
type CryptoCertificate struct {
	// Name The name of the crypto client using this Client Certificate
	Name ClientCertName `json:"name"`

	// RootCA The root CA for the certificate
	RootCA ClientCertRootCA `json:"rootCA"`

	// Subject The subject of the certificate
	Subject ClientCertSubject `json:"subject"`
}

// CryptoCertificateList defines model for CryptoCertificateList.
type CryptoCertificateList struct {
	// Count The total number of Crypto Certificates
	Count *int                `json:"count,omitempty"`
	Value []CryptoCertificate `json:"value"`
}

// DefaultKeystore defines model for DefaultKeystore.
type DefaultKeystore struct {
	// AllowBYOK Keystore supports BYOK keys
	AllowBYOK *bool `json:"allowBYOK,omitempty"`

	// AllowManaged Keystore supports managed keys
	AllowManaged *bool `json:"allowManaged,omitempty"`

	// SupportedRegions Supported region ids
	SupportedRegions *[]string `json:"supportedRegions,omitempty"`
}

// DetailedError defines model for DetailedError.
type DetailedError struct {
	// Code Technical code of the api_errors, used to identify the api_errors condition. This value is stable and can be used to handle specific api_errors cases.
	Code string `json:"code"`

	// Context Additional context of the api_errors
	Context *map[string]interface{} `json:"context,omitempty"`
	Details *[]Error                `json:"details,omitempty"`

	// Message Human readable message describing the reason and context of the api_errors, as well as possible instructions to resolve it. This value is subject to changes over time and must not be used to handle code logic decisions.
	Message  string    `json:"message"`
	MoreInfo *[]string `json:"moreInfo,omitempty"`

	// RequestID The unique identifier of the request
	RequestID *string `json:"requestID,omitempty"`

	// Status HTTP status code
	Status int `json:"status"`

	// Target The object that the api_errors relates to
	Target *string `json:"target,omitempty"`
}

// DetailedWorkflow defines model for DetailedWorkflow.
type DetailedWorkflow struct {
	ActionType WorkflowActionType `json:"actionType"`

	// ApprovalSummary Summary of the approval decisions
	ApprovalSummary *WorkflowApprovalSummary `json:"approvalSummary,omitempty"`

	// ApproverGroups The list of Groups responsible for approving the Workflow
	ApproverGroups []Group `json:"approverGroups"`

	// ArtifactID The ID of the artifact that the Workflow is associated with
	ArtifactID openapi_types.UUID `json:"artifactID"`

	// ArtifactName The name of the artifact that the Workflow is associated with
	ArtifactName *string              `json:"artifactName,omitempty"`
	ArtifactType WorkflowArtifactType `json:"artifactType"`

	// AvailableTransitions The list of available transitions for the Workflow
	AvailableTransitions []WorkflowTransitionValue `json:"availableTransitions"`

	// Decisions The list of decisions made by the approvers
	Decisions []WorkflowApprover `json:"decisions"`

	// ExpiresAt The datetime of when the workflow expires (RFC3339 format)
	ExpiresAt *time.Time `json:"expiresAt,omitempty"`

	// FailureReason The reason for the failure of the Workflow
	FailureReason *string `json:"failureReason,omitempty"`

	// Id The ID of the Workflow
	Id *openapi_types.UUID `json:"id,omitempty"`

	// InitiatorID The ID of the User who initiated the Workflow
	InitiatorID string `json:"initiatorID"`

	// InitiatorName The name of the User who initiated the Workflow
	InitiatorName string            `json:"initiatorName"`
	Metadata      *WorkflowMetadata `json:"metadata,omitempty"`

	// Parameters Parameters required to execute the Workflow
	Parameters *string `json:"parameters,omitempty"`

	// ParametersResourceName The name of the resource derived from the Workflow parameters
	ParametersResourceName *string                         `json:"parametersResourceName,omitempty"`
	ParametersResourceType *WorkflowParametersResourceType `json:"parametersResourceType,omitempty"`
	State                  WorkflowState                   `json:"state"`
}

// Error A structured api_errors response
type Error struct {
	// Code Technical code of the api_errors, used to identify the api_errors condition. This value is stable and can be used to handle specific api_errors cases.
	Code string `json:"code"`

	// Context Additional context of the api_errors
	Context *map[string]interface{} `json:"context,omitempty"`

	// Message Human readable message describing the reason and context of the api_errors, as well as possible instructions to resolve it. This value is subject to changes over time and must not be used to handle code logic decisions.
	Message string `json:"message"`
}

// ErrorMessage defines model for ErrorMessage.
type ErrorMessage struct {
	Error DetailedError `json:"error"`
}

// Group defines model for Group.
type Group struct {
	// Description Description of the Group
	Description *string `json:"description,omitempty"`

	// IamIdentifier Reference of the Group in the customer's Identity & Access Management (IAM) provider
	IamIdentifier *GroupIAMIdentifier `json:"iamIdentifier,omitempty"`

	// Id The ID of the group
	Id *openapi_types.UUID `json:"id,omitempty"`

	// Name Name of the group
	Name string `json:"name"`

	// Role Role of the group
	Role GroupRole `json:"role"`
}

// GroupRole Role of the group
type GroupRole string

// GroupIAMCheckRequest defines model for GroupIAMCheckRequest.
type GroupIAMCheckRequest struct {
	// IamIdentifiers List of IAM Identifiers to check existence in IAM provider
	IamIdentifiers []string `json:"iamIdentifiers"`
}

// GroupIAMCheckResponse defines model for GroupIAMCheckResponse.
type GroupIAMCheckResponse struct {
	Value []GroupIAMExistence `json:"value"`
}

// GroupIAMExistence defines model for GroupIAMExistence.
type GroupIAMExistence struct {
	// Exists Flag indicating whether the group exists in the IAM provider
	Exists bool `json:"exists"`

	// IamIdentifier Reference of the Group in the customer's Identity & Access Management (IAM) provider
	IamIdentifier *GroupIAMIdentifier `json:"iamIdentifier,omitempty"`
}

// GroupIAMIdentifier Reference of the Group in the customer's Identity & Access Management (IAM) provider
type GroupIAMIdentifier = string

// GroupList defines model for GroupList.
type GroupList struct {
	// Count The total number of Groups
	Count *int    `json:"count,omitempty"`
	Value []Group `json:"value"`
}

// GroupPatch A patch for updating a group
type GroupPatch struct {
	// IAMIdentifier IAMIdentifier of the group
	IAMIdentifier *string `json:"IAMIdentifier,omitempty"`

	// Description Description of the Group
	Description *string `json:"description,omitempty"`

	// Name The name of the Group
	Name *string `json:"name,omitempty"`
}

// HYOKKeystore defines model for HYOKKeystore.
type HYOKKeystore struct {
	// Allow HYOK is allowed
	Allow *bool `json:"allow,omitempty"`

	// Providers The list of supported keystores
	Providers *[]string `json:"providers,omitempty"`
}

// ImportParams Import parameters for Bring Your Own Key (BYOK) scenario.
type ImportParams struct {
	// PublicKey The public key to use to encrypt the key material before importing it to the key provider.
	PublicKey         *string            `json:"publicKey,omitempty"`
	WrappingAlgorithm *WrappingAlgorithm `json:"wrappingAlgorithm,omitempty"`
}

// Key defines model for Key.
type Key struct {
	// AccessDetails The access details for the Key
	AccessDetails *KeyAccessDetails `json:"accessDetails,omitempty"`

	// Algorithm The algorithm of the Key
	Algorithm *KeyAlgorithm `json:"algorithm,omitempty"`

	// Description The description of the Key
	Description *string `json:"description,omitempty"`

	// Enabled Flag indicating whether the Key is enabled
	Enabled *bool `json:"enabled,omitempty"`

	// Id The ID of the Key
	Id *KeyID `json:"id,omitempty"`

	// IsPrimary Flag indicating whether this Key is the primary (default) key for its associated key configuration.
	IsPrimary *bool `json:"isPrimary,omitempty"`

	// KeyConfigurationID The ID of the Key Configuration
	KeyConfigurationID KeyConfigurationID `json:"keyConfigurationID"`

	// Metadata Key metadata
	Metadata *KeyMetadata `json:"metadata,omitempty"`

	// Name The name of the Key
	Name KeyName `json:"name"`

	// NativeID The native identifier of the key in the key provider. For customer held key, this is the identifier
	// provided when registering the key. In other cases, this is auto generated; in particular, if the keystore
	// provider is AWS then this identifier is the key alias, if the keystore provider is AZURE then this is the
	// key identifier in full URL format.
	NativeID *string `json:"nativeID,omitempty"`

	// Provider The key provider indicates the service or hyperscaler that manages the keys.
	// Examples include cloud service providers like AWS, Azure, or Google Cloud, which offer key management services.
	Provider *KeyProvider `json:"provider,omitempty"`

	// Region The region where the key is stored
	Region *KeyRegion `json:"region,omitempty"`

	// State Indicates the current state of the Key/Key Version. In addition to ENABLED and DISABLED states, the states PENDING_DELETION, DELETED, FORBIDDEN and UNKNOWN are applicable only to customer held keys. Keys and Versions are in UNKNOWN state if the authentication to the customer key fails due to any reason. FORBIDDEN state is for when a HYOK customer key permission is not granted to the system. DETATCHED state is applicable for keys that have been marked with a detatch call on tenant termination
	State *KeyState `json:"state,omitempty"`

	// Type The type of the Key.
	// - SYSTEM_MANAGED: The Key is managed by the System.
	// - BYOK: Bring Your Own Key (BYOK) is a feature that allows you to securely import cryptographic keys from your
	// own managed keystore or key vault into KMS.
	// - HYOK: Hold Your Own Key (HYOK) is a feature that allows you to register cryptographic keys from your own
	// keystore. KMS connects to your HYOK keystore and enables you to use permitted keys to encrypt data for
	// your applications.
	Type KeyType `json:"type"`
}

// KeyAccessDetails The access details for the Key
type KeyAccessDetails struct {
	// Crypto Access details for cryptographic operations. Follows the following format:
	// "region-1": {
	//     "key1": "value1",
	//     "key2": "value3",
	//     "isEditable": bool // true if system on this region failed to connect
	// },
	Crypto *map[string]interface{} `json:"crypto,omitempty"`

	// Management Access details for management operations.
	Management *map[string]interface{} `json:"management,omitempty"`
}

// KeyAlgorithm The algorithm of the Key
type KeyAlgorithm string

// KeyCommon A Key
type KeyCommon struct {
	// Description The description of the Key
	Description *string `json:"description,omitempty"`

	// Enabled Flag indicating whether the Key is enabled
	Enabled *bool `json:"enabled,omitempty"`

	// Id The ID of the Key
	Id *KeyID `json:"id,omitempty"`

	// IsPrimary Flag indicating whether this Key is the primary (default) key for its associated key configuration.
	IsPrimary *bool `json:"isPrimary,omitempty"`

	// KeyConfigurationID The ID of the Key Configuration
	KeyConfigurationID KeyConfigurationID `json:"keyConfigurationID"`

	// Metadata Key metadata
	Metadata *KeyMetadata `json:"metadata,omitempty"`

	// Name The name of the Key
	Name KeyName `json:"name"`

	// NativeID The native identifier of the key in the key provider. For customer held key, this is the identifier
	// provided when registering the key. In other cases, this is auto generated; in particular, if the keystore
	// provider is AWS then this identifier is the key alias, if the keystore provider is AZURE then this is the
	// key identifier in full URL format.
	NativeID *string `json:"nativeID,omitempty"`

	// State Indicates the current state of the Key/Key Version. In addition to ENABLED and DISABLED states, the states PENDING_DELETION, DELETED, FORBIDDEN and UNKNOWN are applicable only to customer held keys. Keys and Versions are in UNKNOWN state if the authentication to the customer key fails due to any reason. FORBIDDEN state is for when a HYOK customer key permission is not granted to the system. DETATCHED state is applicable for keys that have been marked with a detatch call on tenant termination
	State *KeyState `json:"state,omitempty"`

	// Type The type of the Key.
	// - SYSTEM_MANAGED: The Key is managed by the System.
	// - BYOK: Bring Your Own Key (BYOK) is a feature that allows you to securely import cryptographic keys from your
	// own managed keystore or key vault into KMS.
	// - HYOK: Hold Your Own Key (HYOK) is a feature that allows you to register cryptographic keys from your own
	// keystore. KMS connects to your HYOK keystore and enables you to use permitted keys to encrypt data for
	// your applications.
	Type KeyType `json:"type"`
}

// KeyConfiguration Key Configuration
type KeyConfiguration struct {
	AdminGroup *Group `json:"adminGroup,omitempty"`

	// AdminGroupID The ID of the Group of Users responsible for managing the Key Configuration
	AdminGroupID openapi_types.UUID `json:"adminGroupID"`

	// CanConnectSystems Identifies if key configuration can connect to a system
	CanConnectSystems *bool `json:"canConnectSystems,omitempty"`

	// Description The description of the Key Configuration
	Description *string `json:"description,omitempty"`

	// Id The ID of the Key Configuration
	Id *KeyConfigurationIDReadOnly `json:"id,omitempty"`

	// Metadata Key Configuration metadata
	Metadata *KeyConfigurationMetadata `json:"metadata,omitempty"`

	// Name The name of the Key Configuration
	Name string `json:"name"`

	// PrimaryKeyID The ID of the primary key of the configuration
	PrimaryKeyID *openapi_types.UUID `json:"primaryKeyID,omitempty"`
}

// KeyConfigurationID The ID of the Key Configuration
type KeyConfigurationID = openapi_types.UUID

// KeyConfigurationIDReadOnly The ID of the Key Configuration
type KeyConfigurationIDReadOnly = openapi_types.UUID

// KeyConfigurationList defines model for KeyConfigurationList.
type KeyConfigurationList struct {
	// Count The total number of Key Configurations
	Count *int               `json:"count,omitempty"`
	Value []KeyConfiguration `json:"value"`
}

// KeyConfigurationMetadata Key Configuration metadata
type KeyConfigurationMetadata struct {
	// CreatedAt The datetime of when the object was created (RFC3339 format)
	CreatedAt *CreatedAt `json:"createdAt,omitempty"`

	// CreatorID The ID of the User who created the object
	CreatorID *CreatorID `json:"creatorID,omitempty"`

	// CreatorName The username of the User who created the object
	CreatorName *CreatorName `json:"creatorName,omitempty"`

	// TotalKeys The number of Keys of the Key Configuration
	TotalKeys *int `json:"totalKeys,omitempty"`

	// TotalSystems The number of Systems connected to the Key Configuration
	TotalSystems *int `json:"totalSystems,omitempty"`

	// UpdatedAt The datetime of when the object was last updated, enabled, or disabled (RFC3339 format)
	UpdatedAt *UpdatedAt `json:"updatedAt,omitempty"`
}

// KeyConfigurationPatch A patch for updating a Key Configuration
type KeyConfigurationPatch struct {
	// Description The description of the Key Configuration
	Description *string `json:"description,omitempty"`

	// Name The name of the Key Configuration
	Name *string `json:"name,omitempty"`
}

// KeyID The ID of the Key
type KeyID = openapi_types.UUID

// KeyImport A request to import a key material
type KeyImport struct {
	// WrappedKeyMaterial The wrapped key material to import
	WrappedKeyMaterial string `json:"wrappedKeyMaterial"`
}

// KeyList defines model for KeyList.
type KeyList struct {
	// Count The total number of Keys
	Count *int  `json:"count,omitempty"`
	Value []Key `json:"value"`
}

// KeyMetadata Key metadata
type KeyMetadata struct {
	// CreatedAt The datetime of when the object was created (RFC3339 format)
	CreatedAt *CreatedAt `json:"createdAt,omitempty"`

	// PrimaryVersion The number of the primary Key Version
	PrimaryVersion *KeyPrimaryVersion `json:"primaryVersion,omitempty"`

	// TotalVersions The number of Versions of the Key
	TotalVersions *KeyTotalVersions `json:"totalVersions,omitempty"`

	// UpdatedAt The datetime of when the object was last updated, enabled, or disabled (RFC3339 format)
	UpdatedAt *UpdatedAt `json:"updatedAt,omitempty"`
}

// KeyName The name of the Key
type KeyName = string

// KeyPatch A patch for updating a Key
type KeyPatch struct {
	// AccessDetails The access details for the Key
	AccessDetails *KeyAccessDetails `json:"accessDetails,omitempty"`

	// Description The description of the Key
	Description *string `json:"description,omitempty"`

	// Enabled Flag indicating whether the Key is enabled
	Enabled *bool `json:"enabled,omitempty"`

	// IsPrimary Flag indicating whether this Key is the primary (default) key for its associated key configuration.
	IsPrimary *bool `json:"isPrimary,omitempty"`

	// Name The name of the Key
	Name *string `json:"name,omitempty"`
}

// KeyPrimaryVersion The number of the primary Key Version
type KeyPrimaryVersion = int

// KeyProvider The key provider indicates the service or hyperscaler that manages the keys.
// Examples include cloud service providers like AWS, Azure, or Google Cloud, which offer key management services.
type KeyProvider = string

// KeyRegion The region where the key is stored
type KeyRegion = string

// KeyRotationBody Additional request body that is required for rotation of customer held keys. Must not be provided for non-customer held keys.
type KeyRotationBody struct {
	// NativeID The native identifier of the key to register. For AWS, this is either the key ID or the full key ARN.
	NativeID *string `json:"nativeID,omitempty"`
}

// KeyState Indicates the current state of the Key/Key Version. In addition to ENABLED and DISABLED states, the states PENDING_DELETION, DELETED, FORBIDDEN and UNKNOWN are applicable only to customer held keys. Keys and Versions are in UNKNOWN state if the authentication to the customer key fails due to any reason. FORBIDDEN state is for when a HYOK customer key permission is not granted to the system. DETATCHED state is applicable for keys that have been marked with a detatch call on tenant termination
type KeyState string

// KeyTotalVersions The number of Versions of the Key
type KeyTotalVersions = int

// KeyType The type of the Key.
// - SYSTEM_MANAGED: The Key is managed by the System.
// - BYOK: Bring Your Own Key (BYOK) is a feature that allows you to securely import cryptographic keys from your
// own managed keystore or key vault into KMS.
// - HYOK: Hold Your Own Key (HYOK) is a feature that allows you to register cryptographic keys from your own
// keystore. KMS connects to your HYOK keystore and enables you to use permitted keys to encrypt data for
// your applications.
type KeyType string

// KeyVersion A Key Version
type KeyVersion struct {
	// IsPrimary Indicates if this Version is the primary Version of the Key
	IsPrimary *bool `json:"isPrimary,omitempty"`

	// Metadata Key Version metadata
	Metadata *KeyVersionMetadata `json:"metadata,omitempty"`

	// NativeID The native identifier of the key to register. For AWS, this is either the key ID or
	// the full key ARN.
	NativeID *string `json:"nativeID,omitempty"`

	// Version The Version number of the Key
	Version *int `json:"version,omitempty"`
}

// KeyVersionList defines model for KeyVersionList.
type KeyVersionList struct {
	// Count The total number of Key Versions
	Count *int         `json:"count,omitempty"`
	Value []KeyVersion `json:"value"`
}

// KeyVersionMetadata Key Version metadata
type KeyVersionMetadata struct {
	// CreatedAt The datetime of when the object was created (RFC3339 format)
	CreatedAt *CreatedAt `json:"createdAt,omitempty"`

	// UpdatedAt The datetime of when the object was last updated, enabled, or disabled (RFC3339 format)
	UpdatedAt *UpdatedAt `json:"updatedAt,omitempty"`
}

// Label A Label as a key-value pair
type Label struct {
	// Key A name of a Label
	Key string `json:"key"`

	// Value A value associated with the Label
	Value *string `json:"value,omitempty"`
}

// LabelList A complete list of the Labels associated with a Key along with the count of Labels.
type LabelList struct {
	Count int     `json:"count"`
	Value []Label `json:"value"`
}

// LabelsPostOrPatch defines model for LabelsPostOrPatch.
type LabelsPostOrPatch = []Label

// System A System object
type System struct {
	// ID The ID of System entity
	ID *ID `json:"id,omitempty"`

	// Identifier The identifier of the System entity
	Identifier *Identifier `json:"identifier,omitempty"`

	// KeyConfigurationID The ID of the Key Configuration
	KeyConfigurationID *KeyConfigurationID `json:"keyConfigurationID,omitempty"`

	// KeyConfigurationName The name of the key configuration
	KeyConfigurationName *string                 `json:"keyConfigurationName,omitempty"`
	Properties           *map[string]interface{} `json:"properties,omitempty"`

	// Region The region of the System
	Region string `json:"region"`

	// Status The status of the System
	Status SystemStatus `json:"status"`

	// Type The type of the System
	Type string `json:"type"`
}

// SystemStatus The status of the System
type SystemStatus string

// ID The ID of System entity
type ID = openapi_types.UUID

// Identifier The identifier of the System entity
type Identifier = string

// SystemList defines model for SystemList.
type SystemList struct {
	// Count The total number of Systems
	Count *int `json:"count,omitempty"`

	// SystemsDataRefreshed Indicates whether systems data was synchronized with external system
	SystemsDataRefreshed bool     `json:"systemsDataRefreshed"`
	Value                []System `json:"value"`
}

// SystemPatch Request to update a System object.
type SystemPatch struct {
	// KeyConfigurationID The ID of the Key Configuration
	KeyConfigurationID KeyConfigurationID `json:"keyConfigurationID"`
}

// SystemRecoveryAction System possible actions
type SystemRecoveryAction struct {
	// CanCancel Represents if the system allowed to be reverted to previous state
	CanCancel bool `json:"canCancel"`

	// CanRetry Represents if the previously failed system action can be retried
	CanRetry bool `json:"canRetry"`
}

// SystemRecoveryActionBody System Action Body
type SystemRecoveryActionBody struct {
	// Action The system recovery action
	Action SystemRecoveryActionBodyAction `json:"action"`
}

// SystemRecoveryActionBodyAction The system recovery action
type SystemRecoveryActionBodyAction string

// TagList A list of tags
type TagList struct {
	// Count The total number of tags
	Count *int     `json:"count,omitempty"`
	Value []string `json:"value"`
}

// Tags defines model for Tags.
type Tags struct {
	// Tags List of tags to be added
	Tags []string `json:"tags"`
}

// Tenant defines model for Tenant.
type Tenant struct {
	// Id The ID of tenant
	Id *string `json:"id,omitempty"`

	// Name Name of the tenant
	Name string `json:"name"`

	// Region Region of the tenant
	Region string `json:"region"`
}

// TenantDefaultCertificate A Tenant Default Certificate
type TenantDefaultCertificate struct {
	// Name The name of the crypto client using this Client Certificate
	Name ClientCertName `json:"name"`

	// RootCA The root CA for the certificate
	RootCA ClientCertRootCA `json:"rootCA"`

	// Subject The subject of the certificate
	Subject ClientCertSubject `json:"subject"`
}

// TenantDefaultCertificateList defines model for TenantDefaultCertificateList.
type TenantDefaultCertificateList struct {
	// Count The total number of Client Certificates
	Count *int                       `json:"count,omitempty"`
	Value []TenantDefaultCertificate `json:"value"`
}

// TenantKeystore defines model for TenantKeystore.
type TenantKeystore struct {
	Default *DefaultKeystore `json:"default,omitempty"`
	Hyok    HYOKKeystore     `json:"hyok"`
}

// TenantList defines model for TenantList.
type TenantList struct {
	// Count The total number of Tenants
	Count *int     `json:"count,omitempty"`
	Value []Tenant `json:"value"`
}

// TenantWorkflowConfiguration defines model for TenantWorkflowConfiguration.
type TenantWorkflowConfiguration struct {
	// DefaultExpiryPeriodDays The default number of days before a workflow expires
	DefaultExpiryPeriodDays *int `json:"defaultExpiryPeriodDays,omitempty"`

	// Enabled The flag indicating whether workflow is enabled for the tenant
	Enabled *bool `json:"enabled,omitempty"`

	// MaxExpiryPeriodDays The maximum number of days that can be set for workflow expiry
	MaxExpiryPeriodDays *int `json:"maxExpiryPeriodDays,omitempty"`

	// MinimumApprovals The minimum number of approvals required for a workflow
	MinimumApprovals *int `json:"minimumApprovals,omitempty"`

	// RetentionPeriodDays The number of days to retain completed, failed, revoked, or expired workflow
	RetentionPeriodDays *int `json:"retentionPeriodDays,omitempty"`
}

// UpdatedAt The datetime of when the object was last updated, enabled, or disabled (RFC3339 format)
type UpdatedAt = time.Time

// UserInfo defines model for UserInfo.
type UserInfo struct {
	// Email The email address of the user
	Email string `json:"email"`

	// FamilyName The family name of the user
	FamilyName string `json:"familyName"`

	// GivenName The given name of the user
	GivenName string `json:"givenName"`

	// Identifier The unique identifier of the user
	Identifier string `json:"identifier"`

	// Role The role assigned to the user
	Role string `json:"role"`
}

// Workflow defines model for Workflow.
type Workflow struct {
	ActionType WorkflowActionType `json:"actionType"`

	// ArtifactID The ID of the artifact that the Workflow is associated with
	ArtifactID openapi_types.UUID `json:"artifactID"`

	// ArtifactName The name of the artifact that the Workflow is associated with
	ArtifactName *string              `json:"artifactName,omitempty"`
	ArtifactType WorkflowArtifactType `json:"artifactType"`

	// ExpiresAt The datetime of when the workflow expires (RFC3339 format)
	ExpiresAt *time.Time `json:"expiresAt,omitempty"`

	// FailureReason The reason for the failure of the Workflow
	FailureReason *string `json:"failureReason,omitempty"`

	// Id The ID of the Workflow
	Id *openapi_types.UUID `json:"id,omitempty"`

	// InitiatorID The ID of the User who initiated the Workflow
	InitiatorID string `json:"initiatorID"`

	// InitiatorName The name of the User who initiated the Workflow
	InitiatorName string            `json:"initiatorName"`
	Metadata      *WorkflowMetadata `json:"metadata,omitempty"`

	// Parameters Parameters required to execute the Workflow
	Parameters *string `json:"parameters,omitempty"`

	// ParametersResourceName The name of the resource derived from the Workflow parameters
	ParametersResourceName *string                         `json:"parametersResourceName,omitempty"`
	ParametersResourceType *WorkflowParametersResourceType `json:"parametersResourceType,omitempty"`
	State                  WorkflowState                   `json:"state"`
}

// WorkflowActionType defines model for WorkflowActionType.
type WorkflowActionType = WorkflowActionTypeEnum

// WorkflowActionTypeEnum defines model for WorkflowActionTypeEnum.
type WorkflowActionTypeEnum string

// WorkflowApprovalSummary Summary of the approval decisions
type WorkflowApprovalSummary struct {
	// Approved Number of approved decisions
	Approved *int `json:"approved,omitempty"`

	// Pending Number of pending decisions
	Pending *int `json:"pending,omitempty"`

	// Rejected Number of rejected decisions
	Rejected *int `json:"rejected,omitempty"`

	// TargetScore The target score required for approval.
	TargetScore *int `json:"targetScore,omitempty"`
}

// WorkflowApprover defines model for WorkflowApprover.
type WorkflowApprover struct {
	// Decision The decision of the approver
	Decision WorkflowApproverDecision `json:"decision"`

	// Id The UUID of the Workflow approver.
	Id string `json:"id"`

	// Name The name of the approver
	Name *string `json:"name,omitempty"`
}

// WorkflowApproverDecision The decision of the approver
type WorkflowApproverDecision string

// WorkflowArtifactType defines model for WorkflowArtifactType.
type WorkflowArtifactType = WorkflowArtifactTypeEnum

// WorkflowArtifactTypeEnum defines model for WorkflowArtifactTypeEnum.
type WorkflowArtifactTypeEnum string

// WorkflowBody defines model for WorkflowBody.
type WorkflowBody struct {
	ActionType WorkflowActionType `json:"actionType"`

	// ArtifactID The ID of the artifact that the Workflow is associated with
	ArtifactID   openapi_types.UUID   `json:"artifactID"`
	ArtifactType WorkflowArtifactType `json:"artifactType"`

	// ExpiresAt The datetime of when the workflow expires (RFC3339 format)
	ExpiresAt *time.Time `json:"expiresAt,omitempty"`

	// Parameters Parameters required to execute the Workflow
	Parameters *string `json:"parameters,omitempty"`
}

// WorkflowCheck defines model for WorkflowCheck.
type WorkflowCheck struct {
	// CanCreate If a workflow can be created
	CanCreate *bool `json:"canCreate,omitempty"`

	// Details Workflow canCreate details provides insights on why the canCreate flag is set to false.
	// This is nil whenever canCreate is true
	Details *string `json:"details,omitempty"`

	// Exists If a workflow on the same artifact exists
	Exists *bool `json:"exists,omitempty"`

	// Required If an action requires a workflow
	Required *bool `json:"required,omitempty"`

	// Valid If the workflow arfifact and/or parameters are valid
	Valid *bool `json:"valid,omitempty"`
}

// WorkflowList defines model for WorkflowList.
type WorkflowList struct {
	// Count The total number of Workflows
	Count *int       `json:"count,omitempty"`
	Value []Workflow `json:"value"`
}

// WorkflowMetadata defines model for WorkflowMetadata.
type WorkflowMetadata struct {
	// CreatedAt The datetime of when the object was created (RFC3339 format)
	CreatedAt *CreatedAt `json:"createdAt,omitempty"`

	// UpdatedAt The datetime of when the object was last updated, enabled, or disabled (RFC3339 format)
	UpdatedAt *UpdatedAt `json:"updatedAt,omitempty"`
}

// WorkflowParametersResourceType defines model for WorkflowParametersResourceType.
type WorkflowParametersResourceType = WorkflowParametersResourceTypeEnum

// WorkflowParametersResourceTypeEnum defines model for WorkflowParametersResourceTypeEnum.
type WorkflowParametersResourceTypeEnum string

// WorkflowState defines model for WorkflowState.
type WorkflowState = WorkflowStateEnum

// WorkflowStateEnum defines model for WorkflowStateEnum.
type WorkflowStateEnum string

// WorkflowTransition defines model for WorkflowTransition.
type WorkflowTransition struct {
	Transition WorkflowTransitionValue `json:"transition"`
}

// WorkflowTransitionValue defines model for WorkflowTransitionValue.
type WorkflowTransitionValue string

// WrappingAlgorithm defines model for WrappingAlgorithm.
type WrappingAlgorithm struct {
	// HashFunction Hash function used with the algorithm.
	HashFunction WrappingAlgorithmHashFunction `json:"hashFunction"`

	// Name Algorithm based on PKCS#11 specification, more information can be found
	// [here](https://docs.oasis-open.org/pkcs11/pkcs11-curr/v2.40/cos01/pkcs11-curr-v2.40-cos01.html).
	//
	// - `CKM_RSA_PKCS_OAEP`: A multi-purpose mechanism based on the RSA public-key cryptosystem and the
	// OAEP ((Optimal Asymmetric Encryption Padding) block format defined in PKCS #1.
	// - `CKM_RSA_AES_KEY_WRAP`: A mechanism based on the RSA public-key cryptosystem and the AES key wrap
	// mechanism.
	Name WrappingAlgorithmName `json:"name"`
}

// WrappingAlgorithmHashFunction Hash function used with the algorithm.
type WrappingAlgorithmHashFunction string

// WrappingAlgorithmName Algorithm based on PKCS#11 specification, more information can be found
// [here](https://docs.oasis-open.org/pkcs11/pkcs11-curr/v2.40/cos01/pkcs11-curr-v2.40-cos01.html).
//
// - `CKM_RSA_PKCS_OAEP`: A multi-purpose mechanism based on the RSA public-key cryptosystem and the
// OAEP ((Optimal Asymmetric Encryption Padding) block format defined in PKCS #1.
// - `CKM_RSA_AES_KEY_WRAP`: A mechanism based on the RSA public-key cryptosystem and the AES key wrap
// mechanism.
type WrappingAlgorithmName string

// CountPath defines model for countPath.
type CountPath = bool

// FilterSystems defines model for filterSystems.
type FilterSystems = string

// FilterWorkflows defines model for filterWorkflows.
type FilterWorkflows = string

// GroupIDPath defines model for groupIDPath.
type GroupIDPath = openapi_types.UUID

// KeyConfigurationIDPath defines model for keyConfigurationIDPath.
type KeyConfigurationIDPath = openapi_types.UUID

// KeyIDPath defines model for keyIDPath.
type KeyIDPath = openapi_types.UUID

// KeyVersionNumberPath defines model for keyVersionNumberPath.
type KeyVersionNumberPath = string

// SkipPath defines model for skipPath.
type SkipPath = int

// SystemIDPath defines model for systemIDPath.
type SystemIDPath = openapi_types.UUID

// TopPath defines model for topPath.
type TopPath = int

// WorkflowIDPath defines model for workflowIDPath.
type WorkflowIDPath = openapi_types.UUID

// N400 defines model for 400.
type N400 = ErrorMessage

// N403 defines model for 403.
type N403 = ErrorMessage

// N404 defines model for 404.
type N404 = ErrorMessage

// N409 defines model for 409.
type N409 = ErrorMessage

// N500 defines model for 500.
type N500 = ErrorMessage

// GetGroupsParams defines parameters for GetGroups.
type GetGroupsParams struct {
	// Skip The number of results to skip (default is 0)
	Skip *SkipPath `form:"$skip,omitempty" json:"$skip,omitempty"`

	// Top The number of results to return (default is 20)
	Top *TopPath `form:"$top,omitempty" json:"$top,omitempty"`

	// Count Flag indicating whether to return the total number of results in the queried collection. Using pagination query
	// parameters $skip and $top will not affect this, i.e. the number of returned elements might be smaller than the
	// count value.
	Count *CountPath `form:"$count,omitempty" json:"$count,omitempty"`
}

// GetKeyLabelsParams defines parameters for GetKeyLabels.
type GetKeyLabelsParams struct {
	// Top The number of results to return (default is 20)
	Top *TopPath `form:"$top,omitempty" json:"$top,omitempty"`

	// Skip The number of results to skip (default is 0)
	Skip *SkipPath `form:"$skip,omitempty" json:"$skip,omitempty"`

	// Count Flag indicating whether to return the total number of results in the queried collection. Using pagination query
	// parameters $skip and $top will not affect this, i.e. the number of returned elements might be smaller than the
	// count value.
	Count *CountPath `form:"$count,omitempty" json:"$count,omitempty"`
}

// GetKeyConfigurationsParams defines parameters for GetKeyConfigurations.
type GetKeyConfigurationsParams struct {
	ExpandGroup *bool `form:"expandGroup,omitempty" json:"expandGroup,omitempty"`

	// Skip The number of results to skip (default is 0)
	Skip *SkipPath `form:"$skip,omitempty" json:"$skip,omitempty"`

	// Top The number of results to return (default is 20)
	Top *TopPath `form:"$top,omitempty" json:"$top,omitempty"`

	// Count Flag indicating whether to return the total number of results in the queried collection. Using pagination query
	// parameters $skip and $top will not affect this, i.e. the number of returned elements might be smaller than the
	// count value.
	Count *CountPath `form:"$count,omitempty" json:"$count,omitempty"`
}

// GetKeyConfigurationsCertificatesParams defines parameters for GetKeyConfigurationsCertificates.
type GetKeyConfigurationsCertificatesParams struct {
	// Skip The number of results to skip (default is 0)
	Skip *SkipPath `form:"$skip,omitempty" json:"$skip,omitempty"`

	// Top The number of results to return (default is 20)
	Top *TopPath `form:"$top,omitempty" json:"$top,omitempty"`

	// Count Flag indicating whether to return the total number of results in the queried collection. Using pagination query
	// parameters $skip and $top will not affect this, i.e. the number of returned elements might be smaller than the
	// count value.
	Count *CountPath `form:"$count,omitempty" json:"$count,omitempty"`
}

// GetTagsForKeyConfigurationParams defines parameters for GetTagsForKeyConfiguration.
type GetTagsForKeyConfigurationParams struct {
	// Skip The number of results to skip (default is 0)
	Skip *SkipPath `form:"$skip,omitempty" json:"$skip,omitempty"`

	// Top The number of results to return (default is 20)
	Top *TopPath `form:"$top,omitempty" json:"$top,omitempty"`

	// Count Flag indicating whether to return the total number of results in the queried collection. Using pagination query
	// parameters $skip and $top will not affect this, i.e. the number of returned elements might be smaller than the
	// count value.
	Count *CountPath `form:"$count,omitempty" json:"$count,omitempty"`
}

// GetKeysParams defines parameters for GetKeys.
type GetKeysParams struct {
	// KeyConfigurationID Filter by Key Configuration ID
	KeyConfigurationID openapi_types.UUID `form:"keyConfigurationID" json:"keyConfigurationID"`

	// Skip The number of results to skip (default is 0)
	Skip *SkipPath `form:"$skip,omitempty" json:"$skip,omitempty"`

	// Top The number of results to return (default is 20)
	Top *TopPath `form:"$top,omitempty" json:"$top,omitempty"`

	// Count Flag indicating whether to return the total number of results in the queried collection. Using pagination query
	// parameters $skip and $top will not affect this, i.e. the number of returned elements might be smaller than the
	// count value.
	Count *CountPath `form:"$count,omitempty" json:"$count,omitempty"`
}

// GetKeyVersionsParams defines parameters for GetKeyVersions.
type GetKeyVersionsParams struct {
	// Skip The number of results to skip (default is 0)
	Skip *SkipPath `form:"$skip,omitempty" json:"$skip,omitempty"`

	// Top The number of results to return (default is 20)
	Top *TopPath `form:"$top,omitempty" json:"$top,omitempty"`

	// Count Flag indicating whether to return the total number of results in the queried collection. Using pagination query
	// parameters $skip and $top will not affect this, i.e. the number of returned elements might be smaller than the
	// count value.
	Count *CountPath `form:"$count,omitempty" json:"$count,omitempty"`
}

// GetAllSystemsParams defines parameters for GetAllSystems.
type GetAllSystemsParams struct {
	// Skip The number of results to skip (default is 0)
	Skip *SkipPath `form:"$skip,omitempty" json:"$skip,omitempty"`

	// Top The number of results to return (default is 20)
	Top *TopPath `form:"$top,omitempty" json:"$top,omitempty"`

	// Count Flag indicating whether to return the total number of results in the queried collection. Using pagination query
	// parameters $skip and $top will not affect this, i.e. the number of returned elements might be smaller than the
	// count value.
	Count *CountPath `form:"$count,omitempty" json:"$count,omitempty"`

	// Filter Filter(s) to apply to the results.
	//
	// The following operators are supported:
	//
	// - Equal (eq), on the following attributes: keyConfigurationId, region, role, status and type.
	// - Logical AND (and).
	//
	// Example: region eq eu
	Filter *FilterSystems `form:"$filter,omitempty" json:"$filter,omitempty"`
}

// GetTenantsParams defines parameters for GetTenants.
type GetTenantsParams struct {
	// Skip The number of results to skip (default is 0)
	Skip *SkipPath `form:"$skip,omitempty" json:"$skip,omitempty"`

	// Top The number of results to return (default is 20)
	Top *TopPath `form:"$top,omitempty" json:"$top,omitempty"`

	// Count Flag indicating whether to return the total number of results in the queried collection. Using pagination query
	// parameters $skip and $top will not affect this, i.e. the number of returned elements might be smaller than the
	// count value.
	Count *CountPath `form:"$count,omitempty" json:"$count,omitempty"`
}

// GetWorkflowsParams defines parameters for GetWorkflows.
type GetWorkflowsParams struct {
	// Top The number of results to return (default is 20)
	Top *TopPath `form:"$top,omitempty" json:"$top,omitempty"`

	// Skip The number of results to skip (default is 0)
	Skip *SkipPath `form:"$skip,omitempty" json:"$skip,omitempty"`

	// Count Flag indicating whether to return the total number of results in the queried collection. Using pagination query
	// parameters $skip and $top will not affect this, i.e. the number of returned elements might be smaller than the
	// count value.
	Count *CountPath `form:"$count,omitempty" json:"$count,omitempty"`

	// Filter
	// Filter(s) to apply to the results.
	//
	// The following operators are supported:
	//
	// - Equal (eq), on the following attributes: artifactId, artifactType, artifactName, parametersResourceName, actionType and state.
	// - Logical AND (and).
	//
	// - Valid arguments for `state` are INITIAL, REVOKED, REJECTED, EXPIRED, WAIT_APPROVAL, WAIT_CONFIRMATION, EXECUTING, SUCCESSFUL, FAILED
	// - Valid arguments for `artifactType` are SYSTEM
	// - Valid arguments for `actionType` are LINK, UNLINK, SWITCH
	//
	// Examples:
	//   - state eq INITIAL
	Filter *FilterWorkflows `form:"$filter,omitempty" json:"$filter,omitempty"`
}

// CreateGroupJSONRequestBody defines body for CreateGroup for application/json ContentType.
type CreateGroupJSONRequestBody = Group

// CheckGroupsIAMJSONRequestBody defines body for CheckGroupsIAM for application/json ContentType.
type CheckGroupsIAMJSONRequestBody = GroupIAMCheckRequest

// UpdateGroupApplicationMergePatchPlusJSONRequestBody defines body for UpdateGroup for application/merge-patch+json ContentType.
type UpdateGroupApplicationMergePatchPlusJSONRequestBody = GroupPatch

// CreateOrUpdateLabelsJSONRequestBody defines body for CreateOrUpdateLabels for application/json ContentType.
type CreateOrUpdateLabelsJSONRequestBody = LabelsPostOrPatch

// PostKeyConfigurationsJSONRequestBody defines body for PostKeyConfigurations for application/json ContentType.
type PostKeyConfigurationsJSONRequestBody = KeyConfiguration

// UpdateKeyConfigurationByIDApplicationMergePatchPlusJSONRequestBody defines body for UpdateKeyConfigurationByID for application/merge-patch+json ContentType.
type UpdateKeyConfigurationByIDApplicationMergePatchPlusJSONRequestBody = KeyConfigurationPatch

// AddTagsToKeyConfigurationJSONRequestBody defines body for AddTagsToKeyConfiguration for application/json ContentType.
type AddTagsToKeyConfigurationJSONRequestBody = Tags

// PostKeysJSONRequestBody defines body for PostKeys for application/json ContentType.
type PostKeysJSONRequestBody = Key

// UpdateKeyApplicationMergePatchPlusJSONRequestBody defines body for UpdateKey for application/merge-patch+json ContentType.
type UpdateKeyApplicationMergePatchPlusJSONRequestBody = KeyPatch

// ImportKeyMaterialJSONRequestBody defines body for ImportKeyMaterial for application/json ContentType.
type ImportKeyMaterialJSONRequestBody = KeyImport

// CreateKeyVersionJSONRequestBody defines body for CreateKeyVersion for application/json ContentType.
type CreateKeyVersionJSONRequestBody = KeyRotationBody

// LinkSystemActionApplicationMergePatchPlusJSONRequestBody defines body for LinkSystemAction for application/merge-patch+json ContentType.
type LinkSystemActionApplicationMergePatchPlusJSONRequestBody = SystemPatch

// SendRecoveryActionsJSONRequestBody defines body for SendRecoveryActions for application/json ContentType.
type SendRecoveryActionsJSONRequestBody = SystemRecoveryActionBody

// UpdateTenantWorkflowConfigurationApplicationMergePatchPlusJSONRequestBody defines body for UpdateTenantWorkflowConfiguration for application/merge-patch+json ContentType.
type UpdateTenantWorkflowConfigurationApplicationMergePatchPlusJSONRequestBody = TenantWorkflowConfiguration

// CreateWorkflowJSONRequestBody defines body for CreateWorkflow for application/json ContentType.
type CreateWorkflowJSONRequestBody = WorkflowBody

// CheckWorkflowJSONRequestBody defines body for CheckWorkflow for application/json ContentType.
type CheckWorkflowJSONRequestBody = WorkflowBody

// TransitionWorkflowJSONRequestBody defines body for TransitionWorkflow for application/json ContentType.
type TransitionWorkflowJSONRequestBody = WorkflowTransition

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get Groups
	// (GET /groups)
	GetGroups(w http.ResponseWriter, r *http.Request, params GetGroupsParams)
	// Create a new Group
	// (POST /groups)
	CreateGroup(w http.ResponseWriter, r *http.Request)
	// Check groups existence in IAM provider
	// (POST /groups/iamCheck)
	CheckGroupsIAM(w http.ResponseWriter, r *http.Request)
	// Delete a Group by its ID
	// (DELETE /groups/{groupID})
	DeleteGroupByID(w http.ResponseWriter, r *http.Request, groupID GroupIDPath)
	// Get Group by ID
	// (GET /groups/{groupID})
	GetGroupByID(w http.ResponseWriter, r *http.Request, groupID GroupIDPath)
	// Update group
	// (PATCH /groups/{groupID})
	UpdateGroup(w http.ResponseWriter, r *http.Request, groupID GroupIDPath)
	// Delete a specified Label from a Key
	// (DELETE /key/{keyID}/label/{labelName})
	DeleteLabel(w http.ResponseWriter, r *http.Request, keyID KeyIDPath, labelName string)
	// Get the Labels associated with the Key
	// (GET /key/{keyID}/labels)
	GetKeyLabels(w http.ResponseWriter, r *http.Request, keyID KeyIDPath, params GetKeyLabelsParams)
	// Create and update Labels
	// (POST /key/{keyID}/labels)
	CreateOrUpdateLabels(w http.ResponseWriter, r *http.Request, keyID KeyIDPath)
	// Get all Key Configurations
	// (GET /keyConfigurations)
	GetKeyConfigurations(w http.ResponseWriter, r *http.Request, params GetKeyConfigurationsParams)
	// Create a new Key Configuration
	// (POST /keyConfigurations)
	PostKeyConfigurations(w http.ResponseWriter, r *http.Request)
	// Delete an Key Configuration by its ID
	// (DELETE /keyConfigurations/{keyConfigurationID})
	DeleteKeyConfigurationByID(w http.ResponseWriter, r *http.Request, keyConfigurationID KeyConfigurationIDPath)
	// Get Key Configuration metadata by ID
	// (GET /keyConfigurations/{keyConfigurationID})
	GetKeyConfigurationByID(w http.ResponseWriter, r *http.Request, keyConfigurationID KeyConfigurationIDPath)
	// Update Key Configuration metadata by ID
	// (PATCH /keyConfigurations/{keyConfigurationID})
	UpdateKeyConfigurationByID(w http.ResponseWriter, r *http.Request, keyConfigurationID KeyConfigurationIDPath)
	// Get the client certificate details
	// (GET /keyConfigurations/{keyConfigurationID}/certificates)
	GetKeyConfigurationsCertificates(w http.ResponseWriter, r *http.Request, keyConfigurationID KeyConfigurationIDPath, params GetKeyConfigurationsCertificatesParams)
	// Get list of Tags for a Key Configuration
	// (GET /keyConfigurations/{keyConfigurationID}/tags)
	GetTagsForKeyConfiguration(w http.ResponseWriter, r *http.Request, keyConfigurationID KeyConfigurationIDPath, params GetTagsForKeyConfigurationParams)
	// Either set new Tags or replace Tags for a Key Configuration
	// (PUT /keyConfigurations/{keyConfigurationID}/tags)
	AddTagsToKeyConfiguration(w http.ResponseWriter, r *http.Request, keyConfigurationID KeyConfigurationIDPath)
	// Get metadata of Keys
	// (GET /keys)
	GetKeys(w http.ResponseWriter, r *http.Request, params GetKeysParams)
	// Create a new Key
	// (POST /keys)
	PostKeys(w http.ResponseWriter, r *http.Request)
	// Delete an Key by its ID
	// (DELETE /keys/{keyID})
	DeleteKeysKeyID(w http.ResponseWriter, r *http.Request, keyID KeyIDPath)
	// Get Key metadata by ID
	// (GET /keys/{keyID})
	GetKeysKeyID(w http.ResponseWriter, r *http.Request, keyID KeyIDPath)
	// Update Key metadata by ID
	// (PATCH /keys/{keyID})
	UpdateKey(w http.ResponseWriter, r *http.Request, keyID KeyIDPath)
	// Import a key material
	// (POST /keys/{keyID}/importKeyMaterial)
	ImportKeyMaterial(w http.ResponseWriter, r *http.Request, keyID KeyIDPath)
	// Get import parameters for a Bring Your Own Key (BYOK) key
	// (GET /keys/{keyID}/importParams)
	GetKeyImportParams(w http.ResponseWriter, r *http.Request, keyID KeyIDPath)
	// Get metadata of all Key Versions by Key ID
	// (GET /keys/{keyID}/versions)
	GetKeyVersions(w http.ResponseWriter, r *http.Request, keyID KeyIDPath, params GetKeyVersionsParams)
	// Create a new Key Version
	// (POST /keys/{keyID}/versions)
	CreateKeyVersion(w http.ResponseWriter, r *http.Request, keyID KeyIDPath)
	// Get metadata of a key Version by key ID and Version number
	// (GET /keys/{keyID}/versions/{version})
	GetKeyVersionByNumber(w http.ResponseWriter, r *http.Request, keyID KeyIDPath, version KeyVersionNumberPath)
	// Retrieve all Systems
	// (GET /systems)
	GetAllSystems(w http.ResponseWriter, r *http.Request, params GetAllSystemsParams)
	// Retrieve a System
	// (GET /systems/{systemID})
	GetSystemByID(w http.ResponseWriter, r *http.Request, systemID SystemIDPath)
	// Delete a System link
	// (DELETE /systems/{systemID}/link)
	UnlinkSystemAction(w http.ResponseWriter, r *http.Request, systemID SystemIDPath)
	// Update a System link
	// (PATCH /systems/{systemID}/link)
	LinkSystemAction(w http.ResponseWriter, r *http.Request, systemID SystemIDPath)
	// Possible recovery action
	// (GET /systems/{systemID}/recoveryActions)
	GetRecoveryActions(w http.ResponseWriter, r *http.Request, systemID SystemIDPath)
	// Recovery action
	// (POST /systems/{systemID}/recoveryActions)
	SendRecoveryActions(w http.ResponseWriter, r *http.Request, systemID SystemIDPath)
	// Get tenant keystores
	// (GET /tenantConfigurations/keystores)
	GetTenantKeystores(w http.ResponseWriter, r *http.Request)
	// Get tenant workflow configuration
	// (GET /tenantConfigurations/workflow)
	GetTenantWorkflowConfiguration(w http.ResponseWriter, r *http.Request)
	// Update tenant workflow configuration
	// (PATCH /tenantConfigurations/workflow)
	UpdateTenantWorkflowConfiguration(w http.ResponseWriter, r *http.Request)
	// Get tenant information
	// (GET /tenantInfo)
	GetTenantInfo(w http.ResponseWriter, r *http.Request)
	// Get tenants with same issuer
	// (GET /tenants)
	GetTenants(w http.ResponseWriter, r *http.Request, params GetTenantsParams)
	// Get user information
	// (GET /userInfo)
	GetUserInfo(w http.ResponseWriter, r *http.Request)
	// Get all Workflows
	// (GET /workflows)
	GetWorkflows(w http.ResponseWriter, r *http.Request, params GetWorkflowsParams)
	// Create a new Workflow
	// (POST /workflows)
	CreateWorkflow(w http.ResponseWriter, r *http.Request)
	// Check if workflow is required
	// (POST /workflows/check)
	CheckWorkflow(w http.ResponseWriter, r *http.Request)
	// Get a Workflow
	// (GET /workflows/{workflowID})
	GetWorkflowByID(w http.ResponseWriter, r *http.Request, workflowID WorkflowIDPath)
	// Trigger transition for a Workflow
	// (POST /workflows/{workflowID}/state)
	TransitionWorkflow(w http.ResponseWriter, r *http.Request, workflowID WorkflowIDPath)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// GetGroups operation middleware
func (siw *ServerInterfaceWrapper) GetGroups(w http.ResponseWriter, r *http.Request) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetGroupsParams

	// ------------- Optional query parameter "$skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "$skip", r.URL.Query(), &params.Skip)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "$skip", Err: err})
		return
	}

	// ------------- Optional query parameter "$top" -------------

	err = runtime.BindQueryParameter("form", true, false, "$top", r.URL.Query(), &params.Top)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "$top", Err: err})
		return
	}

	// ------------- Optional query parameter "$count" -------------

	err = runtime.BindQueryParameter("form", true, false, "$count", r.URL.Query(), &params.Count)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "$count", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetGroups(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// CreateGroup operation middleware
func (siw *ServerInterfaceWrapper) CreateGroup(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateGroup(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// CheckGroupsIAM operation middleware
func (siw *ServerInterfaceWrapper) CheckGroupsIAM(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CheckGroupsIAM(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteGroupByID operation middleware
func (siw *ServerInterfaceWrapper) DeleteGroupByID(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "groupID" -------------
	var groupID GroupIDPath

	err = runtime.BindStyledParameterWithOptions("simple", "groupID", r.PathValue("groupID"), &groupID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "groupID", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteGroupByID(w, r, groupID)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetGroupByID operation middleware
func (siw *ServerInterfaceWrapper) GetGroupByID(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "groupID" -------------
	var groupID GroupIDPath

	err = runtime.BindStyledParameterWithOptions("simple", "groupID", r.PathValue("groupID"), &groupID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "groupID", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetGroupByID(w, r, groupID)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// UpdateGroup operation middleware
func (siw *ServerInterfaceWrapper) UpdateGroup(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "groupID" -------------
	var groupID GroupIDPath

	err = runtime.BindStyledParameterWithOptions("simple", "groupID", r.PathValue("groupID"), &groupID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "groupID", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateGroup(w, r, groupID)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteLabel operation middleware
func (siw *ServerInterfaceWrapper) DeleteLabel(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "keyID" -------------
	var keyID KeyIDPath

	err = runtime.BindStyledParameterWithOptions("simple", "keyID", r.PathValue("keyID"), &keyID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "keyID", Err: err})
		return
	}

	// ------------- Path parameter "labelName" -------------
	var labelName string

	err = runtime.BindStyledParameterWithOptions("simple", "labelName", r.PathValue("labelName"), &labelName, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "labelName", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteLabel(w, r, keyID, labelName)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetKeyLabels operation middleware
func (siw *ServerInterfaceWrapper) GetKeyLabels(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "keyID" -------------
	var keyID KeyIDPath

	err = runtime.BindStyledParameterWithOptions("simple", "keyID", r.PathValue("keyID"), &keyID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "keyID", Err: err})
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetKeyLabelsParams

	// ------------- Optional query parameter "$top" -------------

	err = runtime.BindQueryParameter("form", true, false, "$top", r.URL.Query(), &params.Top)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "$top", Err: err})
		return
	}

	// ------------- Optional query parameter "$skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "$skip", r.URL.Query(), &params.Skip)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "$skip", Err: err})
		return
	}

	// ------------- Optional query parameter "$count" -------------

	err = runtime.BindQueryParameter("form", true, false, "$count", r.URL.Query(), &params.Count)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "$count", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetKeyLabels(w, r, keyID, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// CreateOrUpdateLabels operation middleware
func (siw *ServerInterfaceWrapper) CreateOrUpdateLabels(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "keyID" -------------
	var keyID KeyIDPath

	err = runtime.BindStyledParameterWithOptions("simple", "keyID", r.PathValue("keyID"), &keyID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "keyID", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateOrUpdateLabels(w, r, keyID)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetKeyConfigurations operation middleware
func (siw *ServerInterfaceWrapper) GetKeyConfigurations(w http.ResponseWriter, r *http.Request) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetKeyConfigurationsParams

	// ------------- Optional query parameter "expandGroup" -------------

	err = runtime.BindQueryParameter("form", true, false, "expandGroup", r.URL.Query(), &params.ExpandGroup)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "expandGroup", Err: err})
		return
	}

	// ------------- Optional query parameter "$skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "$skip", r.URL.Query(), &params.Skip)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "$skip", Err: err})
		return
	}

	// ------------- Optional query parameter "$top" -------------

	err = runtime.BindQueryParameter("form", true, false, "$top", r.URL.Query(), &params.Top)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "$top", Err: err})
		return
	}

	// ------------- Optional query parameter "$count" -------------

	err = runtime.BindQueryParameter("form", true, false, "$count", r.URL.Query(), &params.Count)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "$count", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetKeyConfigurations(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PostKeyConfigurations operation middleware
func (siw *ServerInterfaceWrapper) PostKeyConfigurations(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostKeyConfigurations(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteKeyConfigurationByID operation middleware
func (siw *ServerInterfaceWrapper) DeleteKeyConfigurationByID(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "keyConfigurationID" -------------
	var keyConfigurationID KeyConfigurationIDPath

	err = runtime.BindStyledParameterWithOptions("simple", "keyConfigurationID", r.PathValue("keyConfigurationID"), &keyConfigurationID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "keyConfigurationID", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteKeyConfigurationByID(w, r, keyConfigurationID)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetKeyConfigurationByID operation middleware
func (siw *ServerInterfaceWrapper) GetKeyConfigurationByID(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "keyConfigurationID" -------------
	var keyConfigurationID KeyConfigurationIDPath

	err = runtime.BindStyledParameterWithOptions("simple", "keyConfigurationID", r.PathValue("keyConfigurationID"), &keyConfigurationID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "keyConfigurationID", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetKeyConfigurationByID(w, r, keyConfigurationID)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// UpdateKeyConfigurationByID operation middleware
func (siw *ServerInterfaceWrapper) UpdateKeyConfigurationByID(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "keyConfigurationID" -------------
	var keyConfigurationID KeyConfigurationIDPath

	err = runtime.BindStyledParameterWithOptions("simple", "keyConfigurationID", r.PathValue("keyConfigurationID"), &keyConfigurationID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "keyConfigurationID", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateKeyConfigurationByID(w, r, keyConfigurationID)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetKeyConfigurationsCertificates operation middleware
func (siw *ServerInterfaceWrapper) GetKeyConfigurationsCertificates(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "keyConfigurationID" -------------
	var keyConfigurationID KeyConfigurationIDPath

	err = runtime.BindStyledParameterWithOptions("simple", "keyConfigurationID", r.PathValue("keyConfigurationID"), &keyConfigurationID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "keyConfigurationID", Err: err})
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetKeyConfigurationsCertificatesParams

	// ------------- Optional query parameter "$skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "$skip", r.URL.Query(), &params.Skip)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "$skip", Err: err})
		return
	}

	// ------------- Optional query parameter "$top" -------------

	err = runtime.BindQueryParameter("form", true, false, "$top", r.URL.Query(), &params.Top)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "$top", Err: err})
		return
	}

	// ------------- Optional query parameter "$count" -------------

	err = runtime.BindQueryParameter("form", true, false, "$count", r.URL.Query(), &params.Count)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "$count", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetKeyConfigurationsCertificates(w, r, keyConfigurationID, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetTagsForKeyConfiguration operation middleware
func (siw *ServerInterfaceWrapper) GetTagsForKeyConfiguration(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "keyConfigurationID" -------------
	var keyConfigurationID KeyConfigurationIDPath

	err = runtime.BindStyledParameterWithOptions("simple", "keyConfigurationID", r.PathValue("keyConfigurationID"), &keyConfigurationID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "keyConfigurationID", Err: err})
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTagsForKeyConfigurationParams

	// ------------- Optional query parameter "$skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "$skip", r.URL.Query(), &params.Skip)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "$skip", Err: err})
		return
	}

	// ------------- Optional query parameter "$top" -------------

	err = runtime.BindQueryParameter("form", true, false, "$top", r.URL.Query(), &params.Top)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "$top", Err: err})
		return
	}

	// ------------- Optional query parameter "$count" -------------

	err = runtime.BindQueryParameter("form", true, false, "$count", r.URL.Query(), &params.Count)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "$count", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetTagsForKeyConfiguration(w, r, keyConfigurationID, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// AddTagsToKeyConfiguration operation middleware
func (siw *ServerInterfaceWrapper) AddTagsToKeyConfiguration(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "keyConfigurationID" -------------
	var keyConfigurationID KeyConfigurationIDPath

	err = runtime.BindStyledParameterWithOptions("simple", "keyConfigurationID", r.PathValue("keyConfigurationID"), &keyConfigurationID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "keyConfigurationID", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AddTagsToKeyConfiguration(w, r, keyConfigurationID)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetKeys operation middleware
func (siw *ServerInterfaceWrapper) GetKeys(w http.ResponseWriter, r *http.Request) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetKeysParams

	// ------------- Required query parameter "keyConfigurationID" -------------

	if paramValue := r.URL.Query().Get("keyConfigurationID"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "keyConfigurationID"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "keyConfigurationID", r.URL.Query(), &params.KeyConfigurationID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "keyConfigurationID", Err: err})
		return
	}

	// ------------- Optional query parameter "$skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "$skip", r.URL.Query(), &params.Skip)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "$skip", Err: err})
		return
	}

	// ------------- Optional query parameter "$top" -------------

	err = runtime.BindQueryParameter("form", true, false, "$top", r.URL.Query(), &params.Top)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "$top", Err: err})
		return
	}

	// ------------- Optional query parameter "$count" -------------

	err = runtime.BindQueryParameter("form", true, false, "$count", r.URL.Query(), &params.Count)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "$count", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetKeys(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PostKeys operation middleware
func (siw *ServerInterfaceWrapper) PostKeys(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostKeys(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteKeysKeyID operation middleware
func (siw *ServerInterfaceWrapper) DeleteKeysKeyID(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "keyID" -------------
	var keyID KeyIDPath

	err = runtime.BindStyledParameterWithOptions("simple", "keyID", r.PathValue("keyID"), &keyID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "keyID", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteKeysKeyID(w, r, keyID)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetKeysKeyID operation middleware
func (siw *ServerInterfaceWrapper) GetKeysKeyID(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "keyID" -------------
	var keyID KeyIDPath

	err = runtime.BindStyledParameterWithOptions("simple", "keyID", r.PathValue("keyID"), &keyID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "keyID", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetKeysKeyID(w, r, keyID)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// UpdateKey operation middleware
func (siw *ServerInterfaceWrapper) UpdateKey(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "keyID" -------------
	var keyID KeyIDPath

	err = runtime.BindStyledParameterWithOptions("simple", "keyID", r.PathValue("keyID"), &keyID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "keyID", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateKey(w, r, keyID)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ImportKeyMaterial operation middleware
func (siw *ServerInterfaceWrapper) ImportKeyMaterial(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "keyID" -------------
	var keyID KeyIDPath

	err = runtime.BindStyledParameterWithOptions("simple", "keyID", r.PathValue("keyID"), &keyID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "keyID", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ImportKeyMaterial(w, r, keyID)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetKeyImportParams operation middleware
func (siw *ServerInterfaceWrapper) GetKeyImportParams(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "keyID" -------------
	var keyID KeyIDPath

	err = runtime.BindStyledParameterWithOptions("simple", "keyID", r.PathValue("keyID"), &keyID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "keyID", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetKeyImportParams(w, r, keyID)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetKeyVersions operation middleware
func (siw *ServerInterfaceWrapper) GetKeyVersions(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "keyID" -------------
	var keyID KeyIDPath

	err = runtime.BindStyledParameterWithOptions("simple", "keyID", r.PathValue("keyID"), &keyID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "keyID", Err: err})
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetKeyVersionsParams

	// ------------- Optional query parameter "$skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "$skip", r.URL.Query(), &params.Skip)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "$skip", Err: err})
		return
	}

	// ------------- Optional query parameter "$top" -------------

	err = runtime.BindQueryParameter("form", true, false, "$top", r.URL.Query(), &params.Top)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "$top", Err: err})
		return
	}

	// ------------- Optional query parameter "$count" -------------

	err = runtime.BindQueryParameter("form", true, false, "$count", r.URL.Query(), &params.Count)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "$count", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetKeyVersions(w, r, keyID, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// CreateKeyVersion operation middleware
func (siw *ServerInterfaceWrapper) CreateKeyVersion(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "keyID" -------------
	var keyID KeyIDPath

	err = runtime.BindStyledParameterWithOptions("simple", "keyID", r.PathValue("keyID"), &keyID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "keyID", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateKeyVersion(w, r, keyID)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetKeyVersionByNumber operation middleware
func (siw *ServerInterfaceWrapper) GetKeyVersionByNumber(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "keyID" -------------
	var keyID KeyIDPath

	err = runtime.BindStyledParameterWithOptions("simple", "keyID", r.PathValue("keyID"), &keyID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "keyID", Err: err})
		return
	}

	// ------------- Path parameter "version" -------------
	var version KeyVersionNumberPath

	err = runtime.BindStyledParameterWithOptions("simple", "version", r.PathValue("version"), &version, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "version", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetKeyVersionByNumber(w, r, keyID, version)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetAllSystems operation middleware
func (siw *ServerInterfaceWrapper) GetAllSystems(w http.ResponseWriter, r *http.Request) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAllSystemsParams

	// ------------- Optional query parameter "$skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "$skip", r.URL.Query(), &params.Skip)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "$skip", Err: err})
		return
	}

	// ------------- Optional query parameter "$top" -------------

	err = runtime.BindQueryParameter("form", true, false, "$top", r.URL.Query(), &params.Top)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "$top", Err: err})
		return
	}

	// ------------- Optional query parameter "$count" -------------

	err = runtime.BindQueryParameter("form", true, false, "$count", r.URL.Query(), &params.Count)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "$count", Err: err})
		return
	}

	// ------------- Optional query parameter "$filter" -------------

	err = runtime.BindQueryParameter("form", true, false, "$filter", r.URL.Query(), &params.Filter)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "$filter", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetAllSystems(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetSystemByID operation middleware
func (siw *ServerInterfaceWrapper) GetSystemByID(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "systemID" -------------
	var systemID SystemIDPath

	err = runtime.BindStyledParameterWithOptions("simple", "systemID", r.PathValue("systemID"), &systemID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "systemID", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetSystemByID(w, r, systemID)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// UnlinkSystemAction operation middleware
func (siw *ServerInterfaceWrapper) UnlinkSystemAction(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "systemID" -------------
	var systemID SystemIDPath

	err = runtime.BindStyledParameterWithOptions("simple", "systemID", r.PathValue("systemID"), &systemID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "systemID", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UnlinkSystemAction(w, r, systemID)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// LinkSystemAction operation middleware
func (siw *ServerInterfaceWrapper) LinkSystemAction(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "systemID" -------------
	var systemID SystemIDPath

	err = runtime.BindStyledParameterWithOptions("simple", "systemID", r.PathValue("systemID"), &systemID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "systemID", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.LinkSystemAction(w, r, systemID)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetRecoveryActions operation middleware
func (siw *ServerInterfaceWrapper) GetRecoveryActions(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "systemID" -------------
	var systemID SystemIDPath

	err = runtime.BindStyledParameterWithOptions("simple", "systemID", r.PathValue("systemID"), &systemID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "systemID", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetRecoveryActions(w, r, systemID)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// SendRecoveryActions operation middleware
func (siw *ServerInterfaceWrapper) SendRecoveryActions(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "systemID" -------------
	var systemID SystemIDPath

	err = runtime.BindStyledParameterWithOptions("simple", "systemID", r.PathValue("systemID"), &systemID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "systemID", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SendRecoveryActions(w, r, systemID)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetTenantKeystores operation middleware
func (siw *ServerInterfaceWrapper) GetTenantKeystores(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetTenantKeystores(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetTenantWorkflowConfiguration operation middleware
func (siw *ServerInterfaceWrapper) GetTenantWorkflowConfiguration(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetTenantWorkflowConfiguration(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// UpdateTenantWorkflowConfiguration operation middleware
func (siw *ServerInterfaceWrapper) UpdateTenantWorkflowConfiguration(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateTenantWorkflowConfiguration(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetTenantInfo operation middleware
func (siw *ServerInterfaceWrapper) GetTenantInfo(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetTenantInfo(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetTenants operation middleware
func (siw *ServerInterfaceWrapper) GetTenants(w http.ResponseWriter, r *http.Request) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTenantsParams

	// ------------- Optional query parameter "$skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "$skip", r.URL.Query(), &params.Skip)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "$skip", Err: err})
		return
	}

	// ------------- Optional query parameter "$top" -------------

	err = runtime.BindQueryParameter("form", true, false, "$top", r.URL.Query(), &params.Top)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "$top", Err: err})
		return
	}

	// ------------- Optional query parameter "$count" -------------

	err = runtime.BindQueryParameter("form", true, false, "$count", r.URL.Query(), &params.Count)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "$count", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetTenants(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetUserInfo operation middleware
func (siw *ServerInterfaceWrapper) GetUserInfo(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetUserInfo(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetWorkflows operation middleware
func (siw *ServerInterfaceWrapper) GetWorkflows(w http.ResponseWriter, r *http.Request) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetWorkflowsParams

	// ------------- Optional query parameter "$top" -------------

	err = runtime.BindQueryParameter("form", true, false, "$top", r.URL.Query(), &params.Top)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "$top", Err: err})
		return
	}

	// ------------- Optional query parameter "$skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "$skip", r.URL.Query(), &params.Skip)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "$skip", Err: err})
		return
	}

	// ------------- Optional query parameter "$count" -------------

	err = runtime.BindQueryParameter("form", true, false, "$count", r.URL.Query(), &params.Count)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "$count", Err: err})
		return
	}

	// ------------- Optional query parameter "$filter" -------------

	err = runtime.BindQueryParameter("form", true, false, "$filter", r.URL.Query(), &params.Filter)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "$filter", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetWorkflows(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// CreateWorkflow operation middleware
func (siw *ServerInterfaceWrapper) CreateWorkflow(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateWorkflow(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// CheckWorkflow operation middleware
func (siw *ServerInterfaceWrapper) CheckWorkflow(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CheckWorkflow(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetWorkflowByID operation middleware
func (siw *ServerInterfaceWrapper) GetWorkflowByID(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "workflowID" -------------
	var workflowID WorkflowIDPath

	err = runtime.BindStyledParameterWithOptions("simple", "workflowID", r.PathValue("workflowID"), &workflowID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "workflowID", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetWorkflowByID(w, r, workflowID)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// TransitionWorkflow operation middleware
func (siw *ServerInterfaceWrapper) TransitionWorkflow(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "workflowID" -------------
	var workflowID WorkflowIDPath

	err = runtime.BindStyledParameterWithOptions("simple", "workflowID", r.PathValue("workflowID"), &workflowID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "workflowID", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.TransitionWorkflow(w, r, workflowID)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{})
}

// ServeMux is an abstraction of http.ServeMux.
type ServeMux interface {
	HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))
	ServeHTTP(w http.ResponseWriter, r *http.Request)
}

type StdHTTPServerOptions struct {
	BaseURL          string
	BaseRouter       ServeMux
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, m ServeMux) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseRouter: m,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, m ServeMux, baseURL string) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseURL:    baseURL,
		BaseRouter: m,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options StdHTTPServerOptions) http.Handler {
	m := options.BaseRouter

	if m == nil {
		m = http.NewServeMux()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	m.HandleFunc("GET "+options.BaseURL+"/groups", wrapper.GetGroups)
	m.HandleFunc("POST "+options.BaseURL+"/groups", wrapper.CreateGroup)
	m.HandleFunc("POST "+options.BaseURL+"/groups/iamCheck", wrapper.CheckGroupsIAM)
	m.HandleFunc("DELETE "+options.BaseURL+"/groups/{groupID}", wrapper.DeleteGroupByID)
	m.HandleFunc("GET "+options.BaseURL+"/groups/{groupID}", wrapper.GetGroupByID)
	m.HandleFunc("PATCH "+options.BaseURL+"/groups/{groupID}", wrapper.UpdateGroup)
	m.HandleFunc("DELETE "+options.BaseURL+"/key/{keyID}/label/{labelName}", wrapper.DeleteLabel)
	m.HandleFunc("GET "+options.BaseURL+"/key/{keyID}/labels", wrapper.GetKeyLabels)
	m.HandleFunc("POST "+options.BaseURL+"/key/{keyID}/labels", wrapper.CreateOrUpdateLabels)
	m.HandleFunc("GET "+options.BaseURL+"/keyConfigurations", wrapper.GetKeyConfigurations)
	m.HandleFunc("POST "+options.BaseURL+"/keyConfigurations", wrapper.PostKeyConfigurations)
	m.HandleFunc("DELETE "+options.BaseURL+"/keyConfigurations/{keyConfigurationID}", wrapper.DeleteKeyConfigurationByID)
	m.HandleFunc("GET "+options.BaseURL+"/keyConfigurations/{keyConfigurationID}", wrapper.GetKeyConfigurationByID)
	m.HandleFunc("PATCH "+options.BaseURL+"/keyConfigurations/{keyConfigurationID}", wrapper.UpdateKeyConfigurationByID)
	m.HandleFunc("GET "+options.BaseURL+"/keyConfigurations/{keyConfigurationID}/certificates", wrapper.GetKeyConfigurationsCertificates)
	m.HandleFunc("GET "+options.BaseURL+"/keyConfigurations/{keyConfigurationID}/tags", wrapper.GetTagsForKeyConfiguration)
	m.HandleFunc("PUT "+options.BaseURL+"/keyConfigurations/{keyConfigurationID}/tags", wrapper.AddTagsToKeyConfiguration)
	m.HandleFunc("GET "+options.BaseURL+"/keys", wrapper.GetKeys)
	m.HandleFunc("POST "+options.BaseURL+"/keys", wrapper.PostKeys)
	m.HandleFunc("DELETE "+options.BaseURL+"/keys/{keyID}", wrapper.DeleteKeysKeyID)
	m.HandleFunc("GET "+options.BaseURL+"/keys/{keyID}", wrapper.GetKeysKeyID)
	m.HandleFunc("PATCH "+options.BaseURL+"/keys/{keyID}", wrapper.UpdateKey)
	m.HandleFunc("POST "+options.BaseURL+"/keys/{keyID}/importKeyMaterial", wrapper.ImportKeyMaterial)
	m.HandleFunc("GET "+options.BaseURL+"/keys/{keyID}/importParams", wrapper.GetKeyImportParams)
	m.HandleFunc("GET "+options.BaseURL+"/keys/{keyID}/versions", wrapper.GetKeyVersions)
	m.HandleFunc("POST "+options.BaseURL+"/keys/{keyID}/versions", wrapper.CreateKeyVersion)
	m.HandleFunc("GET "+options.BaseURL+"/keys/{keyID}/versions/{version}", wrapper.GetKeyVersionByNumber)
	m.HandleFunc("GET "+options.BaseURL+"/systems", wrapper.GetAllSystems)
	m.HandleFunc("GET "+options.BaseURL+"/systems/{systemID}", wrapper.GetSystemByID)
	m.HandleFunc("DELETE "+options.BaseURL+"/systems/{systemID}/link", wrapper.UnlinkSystemAction)
	m.HandleFunc("PATCH "+options.BaseURL+"/systems/{systemID}/link", wrapper.LinkSystemAction)
	m.HandleFunc("GET "+options.BaseURL+"/systems/{systemID}/recoveryActions", wrapper.GetRecoveryActions)
	m.HandleFunc("POST "+options.BaseURL+"/systems/{systemID}/recoveryActions", wrapper.SendRecoveryActions)
	m.HandleFunc("GET "+options.BaseURL+"/tenantConfigurations/keystores", wrapper.GetTenantKeystores)
	m.HandleFunc("GET "+options.BaseURL+"/tenantConfigurations/workflow", wrapper.GetTenantWorkflowConfiguration)
	m.HandleFunc("PATCH "+options.BaseURL+"/tenantConfigurations/workflow", wrapper.UpdateTenantWorkflowConfiguration)
	m.HandleFunc("GET "+options.BaseURL+"/tenantInfo", wrapper.GetTenantInfo)
	m.HandleFunc("GET "+options.BaseURL+"/tenants", wrapper.GetTenants)
	m.HandleFunc("GET "+options.BaseURL+"/userInfo", wrapper.GetUserInfo)
	m.HandleFunc("GET "+options.BaseURL+"/workflows", wrapper.GetWorkflows)
	m.HandleFunc("POST "+options.BaseURL+"/workflows", wrapper.CreateWorkflow)
	m.HandleFunc("POST "+options.BaseURL+"/workflows/check", wrapper.CheckWorkflow)
	m.HandleFunc("GET "+options.BaseURL+"/workflows/{workflowID}", wrapper.GetWorkflowByID)
	m.HandleFunc("POST "+options.BaseURL+"/workflows/{workflowID}/state", wrapper.TransitionWorkflow)

	return m
}

type N400JSONResponse ErrorMessage

type N403JSONResponse ErrorMessage

type N404JSONResponse ErrorMessage

type N409JSONResponse ErrorMessage

type N429ResponseHeaders struct {
	RetryAfter int
}
type N429Response struct {
	Headers N429ResponseHeaders
}

type N500JSONResponse ErrorMessage

type GetGroupsRequestObject struct {
	Params GetGroupsParams
}

type GetGroupsResponseObject interface {
	VisitGetGroupsResponse(w http.ResponseWriter) error
}

type GetGroups200JSONResponse GroupList

func (response GetGroups200JSONResponse) VisitGetGroupsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type GetGroups400JSONResponse struct{ N400JSONResponse }

func (response GetGroups400JSONResponse) VisitGetGroupsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type GetGroups403JSONResponse struct{ N403JSONResponse }

func (response GetGroups403JSONResponse) VisitGetGroupsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type GetGroups429Response = N429Response

func (response GetGroups429Response) VisitGetGroupsResponse(w http.ResponseWriter) error {
	w.Header().Set("Retry-After", fmt.Sprint(response.Headers.RetryAfter))
	w.WriteHeader(429)
	return nil
}

type GetGroups500JSONResponse struct{ N500JSONResponse }

func (response GetGroups500JSONResponse) VisitGetGroupsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type CreateGroupRequestObject struct {
	Body *CreateGroupJSONRequestBody
}

type CreateGroupResponseObject interface {
	VisitCreateGroupResponse(w http.ResponseWriter) error
}

type CreateGroup201JSONResponse Group

func (response CreateGroup201JSONResponse) VisitCreateGroupResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(201)

	return json.NewEncoder(w).Encode(response)
}

type CreateGroup400JSONResponse struct{ N400JSONResponse }

func (response CreateGroup400JSONResponse) VisitCreateGroupResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type CreateGroup403JSONResponse struct{ N403JSONResponse }

func (response CreateGroup403JSONResponse) VisitCreateGroupResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type CreateGroup409JSONResponse struct{ N409JSONResponse }

func (response CreateGroup409JSONResponse) VisitCreateGroupResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(409)

	return json.NewEncoder(w).Encode(response)
}

type CreateGroup429Response = N429Response

func (response CreateGroup429Response) VisitCreateGroupResponse(w http.ResponseWriter) error {
	w.Header().Set("Retry-After", fmt.Sprint(response.Headers.RetryAfter))
	w.WriteHeader(429)
	return nil
}

type CreateGroup500JSONResponse struct{ N500JSONResponse }

func (response CreateGroup500JSONResponse) VisitCreateGroupResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type CheckGroupsIAMRequestObject struct {
	Body *CheckGroupsIAMJSONRequestBody
}

type CheckGroupsIAMResponseObject interface {
	VisitCheckGroupsIAMResponse(w http.ResponseWriter) error
}

type CheckGroupsIAM200JSONResponse GroupIAMCheckResponse

func (response CheckGroupsIAM200JSONResponse) VisitCheckGroupsIAMResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type CheckGroupsIAM400JSONResponse struct{ N400JSONResponse }

func (response CheckGroupsIAM400JSONResponse) VisitCheckGroupsIAMResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type CheckGroupsIAM403JSONResponse struct{ N403JSONResponse }

func (response CheckGroupsIAM403JSONResponse) VisitCheckGroupsIAMResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type CheckGroupsIAM409JSONResponse struct{ N409JSONResponse }

func (response CheckGroupsIAM409JSONResponse) VisitCheckGroupsIAMResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(409)

	return json.NewEncoder(w).Encode(response)
}

type CheckGroupsIAM429Response = N429Response

func (response CheckGroupsIAM429Response) VisitCheckGroupsIAMResponse(w http.ResponseWriter) error {
	w.Header().Set("Retry-After", fmt.Sprint(response.Headers.RetryAfter))
	w.WriteHeader(429)
	return nil
}

type CheckGroupsIAM500JSONResponse struct{ N500JSONResponse }

func (response CheckGroupsIAM500JSONResponse) VisitCheckGroupsIAMResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type DeleteGroupByIDRequestObject struct {
	GroupID GroupIDPath `json:"groupID"`
}

type DeleteGroupByIDResponseObject interface {
	VisitDeleteGroupByIDResponse(w http.ResponseWriter) error
}

type DeleteGroupByID204Response struct {
}

func (response DeleteGroupByID204Response) VisitDeleteGroupByIDResponse(w http.ResponseWriter) error {
	w.WriteHeader(204)
	return nil
}

type DeleteGroupByID400JSONResponse struct{ N400JSONResponse }

func (response DeleteGroupByID400JSONResponse) VisitDeleteGroupByIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type DeleteGroupByID403JSONResponse struct{ N403JSONResponse }

func (response DeleteGroupByID403JSONResponse) VisitDeleteGroupByIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type DeleteGroupByID404JSONResponse struct{ N404JSONResponse }

func (response DeleteGroupByID404JSONResponse) VisitDeleteGroupByIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type DeleteGroupByID429Response = N429Response

func (response DeleteGroupByID429Response) VisitDeleteGroupByIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Retry-After", fmt.Sprint(response.Headers.RetryAfter))
	w.WriteHeader(429)
	return nil
}

type DeleteGroupByID500JSONResponse struct{ N500JSONResponse }

func (response DeleteGroupByID500JSONResponse) VisitDeleteGroupByIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type GetGroupByIDRequestObject struct {
	GroupID GroupIDPath `json:"groupID"`
}

type GetGroupByIDResponseObject interface {
	VisitGetGroupByIDResponse(w http.ResponseWriter) error
}

type GetGroupByID200JSONResponse Group

func (response GetGroupByID200JSONResponse) VisitGetGroupByIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type GetGroupByID400JSONResponse struct{ N400JSONResponse }

func (response GetGroupByID400JSONResponse) VisitGetGroupByIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type GetGroupByID403JSONResponse struct{ N403JSONResponse }

func (response GetGroupByID403JSONResponse) VisitGetGroupByIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type GetGroupByID429Response = N429Response

func (response GetGroupByID429Response) VisitGetGroupByIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Retry-After", fmt.Sprint(response.Headers.RetryAfter))
	w.WriteHeader(429)
	return nil
}

type GetGroupByID500JSONResponse struct{ N500JSONResponse }

func (response GetGroupByID500JSONResponse) VisitGetGroupByIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type UpdateGroupRequestObject struct {
	GroupID GroupIDPath `json:"groupID"`
	Body    *UpdateGroupApplicationMergePatchPlusJSONRequestBody
}

type UpdateGroupResponseObject interface {
	VisitUpdateGroupResponse(w http.ResponseWriter) error
}

type UpdateGroup200JSONResponse Group

func (response UpdateGroup200JSONResponse) VisitUpdateGroupResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type UpdateGroup400JSONResponse struct{ N400JSONResponse }

func (response UpdateGroup400JSONResponse) VisitUpdateGroupResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type UpdateGroup403JSONResponse struct{ N403JSONResponse }

func (response UpdateGroup403JSONResponse) VisitUpdateGroupResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type UpdateGroup404JSONResponse struct{ N404JSONResponse }

func (response UpdateGroup404JSONResponse) VisitUpdateGroupResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type UpdateGroup409JSONResponse struct{ N409JSONResponse }

func (response UpdateGroup409JSONResponse) VisitUpdateGroupResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(409)

	return json.NewEncoder(w).Encode(response)
}

type UpdateGroup429Response = N429Response

func (response UpdateGroup429Response) VisitUpdateGroupResponse(w http.ResponseWriter) error {
	w.Header().Set("Retry-After", fmt.Sprint(response.Headers.RetryAfter))
	w.WriteHeader(429)
	return nil
}

type UpdateGroup500JSONResponse struct{ N500JSONResponse }

func (response UpdateGroup500JSONResponse) VisitUpdateGroupResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type DeleteLabelRequestObject struct {
	KeyID     KeyIDPath `json:"keyID"`
	LabelName string    `json:"labelName"`
}

type DeleteLabelResponseObject interface {
	VisitDeleteLabelResponse(w http.ResponseWriter) error
}

type DeleteLabel204Response struct {
}

func (response DeleteLabel204Response) VisitDeleteLabelResponse(w http.ResponseWriter) error {
	w.WriteHeader(204)
	return nil
}

type DeleteLabel400JSONResponse struct{ N400JSONResponse }

func (response DeleteLabel400JSONResponse) VisitDeleteLabelResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type DeleteLabel403JSONResponse struct{ N403JSONResponse }

func (response DeleteLabel403JSONResponse) VisitDeleteLabelResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type DeleteLabel404JSONResponse struct{ N404JSONResponse }

func (response DeleteLabel404JSONResponse) VisitDeleteLabelResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type DeleteLabel429Response = N429Response

func (response DeleteLabel429Response) VisitDeleteLabelResponse(w http.ResponseWriter) error {
	w.Header().Set("Retry-After", fmt.Sprint(response.Headers.RetryAfter))
	w.WriteHeader(429)
	return nil
}

type DeleteLabel500JSONResponse struct{ N500JSONResponse }

func (response DeleteLabel500JSONResponse) VisitDeleteLabelResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type GetKeyLabelsRequestObject struct {
	KeyID  KeyIDPath `json:"keyID"`
	Params GetKeyLabelsParams
}

type GetKeyLabelsResponseObject interface {
	VisitGetKeyLabelsResponse(w http.ResponseWriter) error
}

type GetKeyLabels200JSONResponse LabelList

func (response GetKeyLabels200JSONResponse) VisitGetKeyLabelsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type GetKeyLabels400JSONResponse struct{ N400JSONResponse }

func (response GetKeyLabels400JSONResponse) VisitGetKeyLabelsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type GetKeyLabels403JSONResponse struct{ N403JSONResponse }

func (response GetKeyLabels403JSONResponse) VisitGetKeyLabelsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type GetKeyLabels404JSONResponse struct{ N404JSONResponse }

func (response GetKeyLabels404JSONResponse) VisitGetKeyLabelsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type GetKeyLabels429Response = N429Response

func (response GetKeyLabels429Response) VisitGetKeyLabelsResponse(w http.ResponseWriter) error {
	w.Header().Set("Retry-After", fmt.Sprint(response.Headers.RetryAfter))
	w.WriteHeader(429)
	return nil
}

type GetKeyLabels500JSONResponse struct{ N500JSONResponse }

func (response GetKeyLabels500JSONResponse) VisitGetKeyLabelsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type CreateOrUpdateLabelsRequestObject struct {
	KeyID KeyIDPath `json:"keyID"`
	Body  *CreateOrUpdateLabelsJSONRequestBody
}

type CreateOrUpdateLabelsResponseObject interface {
	VisitCreateOrUpdateLabelsResponse(w http.ResponseWriter) error
}

type CreateOrUpdateLabels204Response struct {
}

func (response CreateOrUpdateLabels204Response) VisitCreateOrUpdateLabelsResponse(w http.ResponseWriter) error {
	w.WriteHeader(204)
	return nil
}

type CreateOrUpdateLabels400JSONResponse struct{ N400JSONResponse }

func (response CreateOrUpdateLabels400JSONResponse) VisitCreateOrUpdateLabelsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type CreateOrUpdateLabels403JSONResponse struct{ N403JSONResponse }

func (response CreateOrUpdateLabels403JSONResponse) VisitCreateOrUpdateLabelsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type CreateOrUpdateLabels404JSONResponse struct{ N404JSONResponse }

func (response CreateOrUpdateLabels404JSONResponse) VisitCreateOrUpdateLabelsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type CreateOrUpdateLabels429Response = N429Response

func (response CreateOrUpdateLabels429Response) VisitCreateOrUpdateLabelsResponse(w http.ResponseWriter) error {
	w.Header().Set("Retry-After", fmt.Sprint(response.Headers.RetryAfter))
	w.WriteHeader(429)
	return nil
}

type CreateOrUpdateLabels500JSONResponse struct{ N500JSONResponse }

func (response CreateOrUpdateLabels500JSONResponse) VisitCreateOrUpdateLabelsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type GetKeyConfigurationsRequestObject struct {
	Params GetKeyConfigurationsParams
}

type GetKeyConfigurationsResponseObject interface {
	VisitGetKeyConfigurationsResponse(w http.ResponseWriter) error
}

type GetKeyConfigurations200JSONResponse KeyConfigurationList

func (response GetKeyConfigurations200JSONResponse) VisitGetKeyConfigurationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type GetKeyConfigurations400JSONResponse struct{ N400JSONResponse }

func (response GetKeyConfigurations400JSONResponse) VisitGetKeyConfigurationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type GetKeyConfigurations403JSONResponse struct{ N403JSONResponse }

func (response GetKeyConfigurations403JSONResponse) VisitGetKeyConfigurationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type GetKeyConfigurations429Response = N429Response

func (response GetKeyConfigurations429Response) VisitGetKeyConfigurationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Retry-After", fmt.Sprint(response.Headers.RetryAfter))
	w.WriteHeader(429)
	return nil
}

type GetKeyConfigurations500JSONResponse struct{ N500JSONResponse }

func (response GetKeyConfigurations500JSONResponse) VisitGetKeyConfigurationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type PostKeyConfigurationsRequestObject struct {
	Body *PostKeyConfigurationsJSONRequestBody
}

type PostKeyConfigurationsResponseObject interface {
	VisitPostKeyConfigurationsResponse(w http.ResponseWriter) error
}

type PostKeyConfigurations201JSONResponse KeyConfiguration

func (response PostKeyConfigurations201JSONResponse) VisitPostKeyConfigurationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(201)

	return json.NewEncoder(w).Encode(response)
}

type PostKeyConfigurations400JSONResponse struct{ N400JSONResponse }

func (response PostKeyConfigurations400JSONResponse) VisitPostKeyConfigurationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type PostKeyConfigurations403JSONResponse struct{ N403JSONResponse }

func (response PostKeyConfigurations403JSONResponse) VisitPostKeyConfigurationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type PostKeyConfigurations409JSONResponse struct{ N409JSONResponse }

func (response PostKeyConfigurations409JSONResponse) VisitPostKeyConfigurationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(409)

	return json.NewEncoder(w).Encode(response)
}

type PostKeyConfigurations429Response = N429Response

func (response PostKeyConfigurations429Response) VisitPostKeyConfigurationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Retry-After", fmt.Sprint(response.Headers.RetryAfter))
	w.WriteHeader(429)
	return nil
}

type PostKeyConfigurations500JSONResponse struct{ N500JSONResponse }

func (response PostKeyConfigurations500JSONResponse) VisitPostKeyConfigurationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type DeleteKeyConfigurationByIDRequestObject struct {
	KeyConfigurationID KeyConfigurationIDPath `json:"keyConfigurationID"`
}

type DeleteKeyConfigurationByIDResponseObject interface {
	VisitDeleteKeyConfigurationByIDResponse(w http.ResponseWriter) error
}

type DeleteKeyConfigurationByID204Response struct {
}

func (response DeleteKeyConfigurationByID204Response) VisitDeleteKeyConfigurationByIDResponse(w http.ResponseWriter) error {
	w.WriteHeader(204)
	return nil
}

type DeleteKeyConfigurationByID400JSONResponse struct{ N400JSONResponse }

func (response DeleteKeyConfigurationByID400JSONResponse) VisitDeleteKeyConfigurationByIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type DeleteKeyConfigurationByID403JSONResponse struct{ N403JSONResponse }

func (response DeleteKeyConfigurationByID403JSONResponse) VisitDeleteKeyConfigurationByIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type DeleteKeyConfigurationByID404JSONResponse struct{ N404JSONResponse }

func (response DeleteKeyConfigurationByID404JSONResponse) VisitDeleteKeyConfigurationByIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type DeleteKeyConfigurationByID429Response = N429Response

func (response DeleteKeyConfigurationByID429Response) VisitDeleteKeyConfigurationByIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Retry-After", fmt.Sprint(response.Headers.RetryAfter))
	w.WriteHeader(429)
	return nil
}

type DeleteKeyConfigurationByID500JSONResponse struct{ N500JSONResponse }

func (response DeleteKeyConfigurationByID500JSONResponse) VisitDeleteKeyConfigurationByIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type GetKeyConfigurationByIDRequestObject struct {
	KeyConfigurationID KeyConfigurationIDPath `json:"keyConfigurationID"`
}

type GetKeyConfigurationByIDResponseObject interface {
	VisitGetKeyConfigurationByIDResponse(w http.ResponseWriter) error
}

type GetKeyConfigurationByID200JSONResponse KeyConfiguration

func (response GetKeyConfigurationByID200JSONResponse) VisitGetKeyConfigurationByIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type GetKeyConfigurationByID400JSONResponse struct{ N400JSONResponse }

func (response GetKeyConfigurationByID400JSONResponse) VisitGetKeyConfigurationByIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type GetKeyConfigurationByID403JSONResponse struct{ N403JSONResponse }

func (response GetKeyConfigurationByID403JSONResponse) VisitGetKeyConfigurationByIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type GetKeyConfigurationByID404JSONResponse struct{ N404JSONResponse }

func (response GetKeyConfigurationByID404JSONResponse) VisitGetKeyConfigurationByIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type GetKeyConfigurationByID429Response = N429Response

func (response GetKeyConfigurationByID429Response) VisitGetKeyConfigurationByIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Retry-After", fmt.Sprint(response.Headers.RetryAfter))
	w.WriteHeader(429)
	return nil
}

type GetKeyConfigurationByID500JSONResponse struct{ N500JSONResponse }

func (response GetKeyConfigurationByID500JSONResponse) VisitGetKeyConfigurationByIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type UpdateKeyConfigurationByIDRequestObject struct {
	KeyConfigurationID KeyConfigurationIDPath `json:"keyConfigurationID"`
	Body               *UpdateKeyConfigurationByIDApplicationMergePatchPlusJSONRequestBody
}

type UpdateKeyConfigurationByIDResponseObject interface {
	VisitUpdateKeyConfigurationByIDResponse(w http.ResponseWriter) error
}

type UpdateKeyConfigurationByID200JSONResponse KeyConfiguration

func (response UpdateKeyConfigurationByID200JSONResponse) VisitUpdateKeyConfigurationByIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type UpdateKeyConfigurationByID400JSONResponse struct{ N400JSONResponse }

func (response UpdateKeyConfigurationByID400JSONResponse) VisitUpdateKeyConfigurationByIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type UpdateKeyConfigurationByID403JSONResponse struct{ N403JSONResponse }

func (response UpdateKeyConfigurationByID403JSONResponse) VisitUpdateKeyConfigurationByIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type UpdateKeyConfigurationByID404JSONResponse struct{ N404JSONResponse }

func (response UpdateKeyConfigurationByID404JSONResponse) VisitUpdateKeyConfigurationByIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type UpdateKeyConfigurationByID409JSONResponse struct{ N409JSONResponse }

func (response UpdateKeyConfigurationByID409JSONResponse) VisitUpdateKeyConfigurationByIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(409)

	return json.NewEncoder(w).Encode(response)
}

type UpdateKeyConfigurationByID429Response = N429Response

func (response UpdateKeyConfigurationByID429Response) VisitUpdateKeyConfigurationByIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Retry-After", fmt.Sprint(response.Headers.RetryAfter))
	w.WriteHeader(429)
	return nil
}

type UpdateKeyConfigurationByID500JSONResponse struct{ N500JSONResponse }

func (response UpdateKeyConfigurationByID500JSONResponse) VisitUpdateKeyConfigurationByIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type GetKeyConfigurationsCertificatesRequestObject struct {
	KeyConfigurationID KeyConfigurationIDPath `json:"keyConfigurationID"`
	Params             GetKeyConfigurationsCertificatesParams
}

type GetKeyConfigurationsCertificatesResponseObject interface {
	VisitGetKeyConfigurationsCertificatesResponse(w http.ResponseWriter) error
}

type GetKeyConfigurationsCertificates200JSONResponse ClientCertificates

func (response GetKeyConfigurationsCertificates200JSONResponse) VisitGetKeyConfigurationsCertificatesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type GetKeyConfigurationsCertificates400JSONResponse struct{ N400JSONResponse }

func (response GetKeyConfigurationsCertificates400JSONResponse) VisitGetKeyConfigurationsCertificatesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type GetKeyConfigurationsCertificates403JSONResponse struct{ N403JSONResponse }

func (response GetKeyConfigurationsCertificates403JSONResponse) VisitGetKeyConfigurationsCertificatesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type GetKeyConfigurationsCertificates429Response = N429Response

func (response GetKeyConfigurationsCertificates429Response) VisitGetKeyConfigurationsCertificatesResponse(w http.ResponseWriter) error {
	w.Header().Set("Retry-After", fmt.Sprint(response.Headers.RetryAfter))
	w.WriteHeader(429)
	return nil
}

type GetKeyConfigurationsCertificates500JSONResponse struct{ N500JSONResponse }

func (response GetKeyConfigurationsCertificates500JSONResponse) VisitGetKeyConfigurationsCertificatesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type GetTagsForKeyConfigurationRequestObject struct {
	KeyConfigurationID KeyConfigurationIDPath `json:"keyConfigurationID"`
	Params             GetTagsForKeyConfigurationParams
}

type GetTagsForKeyConfigurationResponseObject interface {
	VisitGetTagsForKeyConfigurationResponse(w http.ResponseWriter) error
}

type GetTagsForKeyConfiguration200JSONResponse TagList

func (response GetTagsForKeyConfiguration200JSONResponse) VisitGetTagsForKeyConfigurationResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type GetTagsForKeyConfiguration400JSONResponse struct{ N400JSONResponse }

func (response GetTagsForKeyConfiguration400JSONResponse) VisitGetTagsForKeyConfigurationResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type GetTagsForKeyConfiguration403JSONResponse struct{ N403JSONResponse }

func (response GetTagsForKeyConfiguration403JSONResponse) VisitGetTagsForKeyConfigurationResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type GetTagsForKeyConfiguration404JSONResponse struct{ N404JSONResponse }

func (response GetTagsForKeyConfiguration404JSONResponse) VisitGetTagsForKeyConfigurationResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type GetTagsForKeyConfiguration429Response = N429Response

func (response GetTagsForKeyConfiguration429Response) VisitGetTagsForKeyConfigurationResponse(w http.ResponseWriter) error {
	w.Header().Set("Retry-After", fmt.Sprint(response.Headers.RetryAfter))
	w.WriteHeader(429)
	return nil
}

type GetTagsForKeyConfiguration500JSONResponse struct{ N500JSONResponse }

func (response GetTagsForKeyConfiguration500JSONResponse) VisitGetTagsForKeyConfigurationResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type AddTagsToKeyConfigurationRequestObject struct {
	KeyConfigurationID KeyConfigurationIDPath `json:"keyConfigurationID"`
	Body               *AddTagsToKeyConfigurationJSONRequestBody
}

type AddTagsToKeyConfigurationResponseObject interface {
	VisitAddTagsToKeyConfigurationResponse(w http.ResponseWriter) error
}

type AddTagsToKeyConfiguration204Response struct {
}

func (response AddTagsToKeyConfiguration204Response) VisitAddTagsToKeyConfigurationResponse(w http.ResponseWriter) error {
	w.WriteHeader(204)
	return nil
}

type AddTagsToKeyConfiguration400JSONResponse struct{ N400JSONResponse }

func (response AddTagsToKeyConfiguration400JSONResponse) VisitAddTagsToKeyConfigurationResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type AddTagsToKeyConfiguration403JSONResponse struct{ N403JSONResponse }

func (response AddTagsToKeyConfiguration403JSONResponse) VisitAddTagsToKeyConfigurationResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type AddTagsToKeyConfiguration404JSONResponse struct{ N404JSONResponse }

func (response AddTagsToKeyConfiguration404JSONResponse) VisitAddTagsToKeyConfigurationResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type AddTagsToKeyConfiguration409JSONResponse struct{ N409JSONResponse }

func (response AddTagsToKeyConfiguration409JSONResponse) VisitAddTagsToKeyConfigurationResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(409)

	return json.NewEncoder(w).Encode(response)
}

type AddTagsToKeyConfiguration429Response = N429Response

func (response AddTagsToKeyConfiguration429Response) VisitAddTagsToKeyConfigurationResponse(w http.ResponseWriter) error {
	w.Header().Set("Retry-After", fmt.Sprint(response.Headers.RetryAfter))
	w.WriteHeader(429)
	return nil
}

type AddTagsToKeyConfiguration500JSONResponse struct{ N500JSONResponse }

func (response AddTagsToKeyConfiguration500JSONResponse) VisitAddTagsToKeyConfigurationResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type GetKeysRequestObject struct {
	Params GetKeysParams
}

type GetKeysResponseObject interface {
	VisitGetKeysResponse(w http.ResponseWriter) error
}

type GetKeys200JSONResponse KeyList

func (response GetKeys200JSONResponse) VisitGetKeysResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type GetKeys400JSONResponse struct{ N400JSONResponse }

func (response GetKeys400JSONResponse) VisitGetKeysResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type GetKeys403JSONResponse struct{ N403JSONResponse }

func (response GetKeys403JSONResponse) VisitGetKeysResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type GetKeys429Response = N429Response

func (response GetKeys429Response) VisitGetKeysResponse(w http.ResponseWriter) error {
	w.Header().Set("Retry-After", fmt.Sprint(response.Headers.RetryAfter))
	w.WriteHeader(429)
	return nil
}

type GetKeys500JSONResponse struct{ N500JSONResponse }

func (response GetKeys500JSONResponse) VisitGetKeysResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type PostKeysRequestObject struct {
	Body *PostKeysJSONRequestBody
}

type PostKeysResponseObject interface {
	VisitPostKeysResponse(w http.ResponseWriter) error
}

type PostKeys201JSONResponse Key

func (response PostKeys201JSONResponse) VisitPostKeysResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(201)

	return json.NewEncoder(w).Encode(response)
}

type PostKeys400JSONResponse struct{ N400JSONResponse }

func (response PostKeys400JSONResponse) VisitPostKeysResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type PostKeys403JSONResponse struct{ N403JSONResponse }

func (response PostKeys403JSONResponse) VisitPostKeysResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type PostKeys409JSONResponse struct{ N409JSONResponse }

func (response PostKeys409JSONResponse) VisitPostKeysResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(409)

	return json.NewEncoder(w).Encode(response)
}

type PostKeys429Response = N429Response

func (response PostKeys429Response) VisitPostKeysResponse(w http.ResponseWriter) error {
	w.Header().Set("Retry-After", fmt.Sprint(response.Headers.RetryAfter))
	w.WriteHeader(429)
	return nil
}

type PostKeys500JSONResponse struct{ N500JSONResponse }

func (response PostKeys500JSONResponse) VisitPostKeysResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type DeleteKeysKeyIDRequestObject struct {
	KeyID KeyIDPath `json:"keyID"`
}

type DeleteKeysKeyIDResponseObject interface {
	VisitDeleteKeysKeyIDResponse(w http.ResponseWriter) error
}

type DeleteKeysKeyID204Response struct {
}

func (response DeleteKeysKeyID204Response) VisitDeleteKeysKeyIDResponse(w http.ResponseWriter) error {
	w.WriteHeader(204)
	return nil
}

type DeleteKeysKeyID400JSONResponse struct{ N400JSONResponse }

func (response DeleteKeysKeyID400JSONResponse) VisitDeleteKeysKeyIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type DeleteKeysKeyID403JSONResponse struct{ N403JSONResponse }

func (response DeleteKeysKeyID403JSONResponse) VisitDeleteKeysKeyIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type DeleteKeysKeyID404JSONResponse struct{ N404JSONResponse }

func (response DeleteKeysKeyID404JSONResponse) VisitDeleteKeysKeyIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type DeleteKeysKeyID429Response = N429Response

func (response DeleteKeysKeyID429Response) VisitDeleteKeysKeyIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Retry-After", fmt.Sprint(response.Headers.RetryAfter))
	w.WriteHeader(429)
	return nil
}

type DeleteKeysKeyID500JSONResponse struct{ N500JSONResponse }

func (response DeleteKeysKeyID500JSONResponse) VisitDeleteKeysKeyIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type GetKeysKeyIDRequestObject struct {
	KeyID KeyIDPath `json:"keyID"`
}

type GetKeysKeyIDResponseObject interface {
	VisitGetKeysKeyIDResponse(w http.ResponseWriter) error
}

type GetKeysKeyID200JSONResponse Key

func (response GetKeysKeyID200JSONResponse) VisitGetKeysKeyIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type GetKeysKeyID400JSONResponse struct{ N400JSONResponse }

func (response GetKeysKeyID400JSONResponse) VisitGetKeysKeyIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type GetKeysKeyID403JSONResponse struct{ N403JSONResponse }

func (response GetKeysKeyID403JSONResponse) VisitGetKeysKeyIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type GetKeysKeyID404JSONResponse struct{ N404JSONResponse }

func (response GetKeysKeyID404JSONResponse) VisitGetKeysKeyIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type GetKeysKeyID429Response = N429Response

func (response GetKeysKeyID429Response) VisitGetKeysKeyIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Retry-After", fmt.Sprint(response.Headers.RetryAfter))
	w.WriteHeader(429)
	return nil
}

type GetKeysKeyID500JSONResponse struct{ N500JSONResponse }

func (response GetKeysKeyID500JSONResponse) VisitGetKeysKeyIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type UpdateKeyRequestObject struct {
	KeyID KeyIDPath `json:"keyID"`
	Body  *UpdateKeyApplicationMergePatchPlusJSONRequestBody
}

type UpdateKeyResponseObject interface {
	VisitUpdateKeyResponse(w http.ResponseWriter) error
}

type UpdateKey200JSONResponse Key

func (response UpdateKey200JSONResponse) VisitUpdateKeyResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type UpdateKey400JSONResponse struct{ N400JSONResponse }

func (response UpdateKey400JSONResponse) VisitUpdateKeyResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type UpdateKey403JSONResponse struct{ N403JSONResponse }

func (response UpdateKey403JSONResponse) VisitUpdateKeyResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type UpdateKey404JSONResponse struct{ N404JSONResponse }

func (response UpdateKey404JSONResponse) VisitUpdateKeyResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type UpdateKey409JSONResponse struct{ N409JSONResponse }

func (response UpdateKey409JSONResponse) VisitUpdateKeyResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(409)

	return json.NewEncoder(w).Encode(response)
}

type UpdateKey429Response = N429Response

func (response UpdateKey429Response) VisitUpdateKeyResponse(w http.ResponseWriter) error {
	w.Header().Set("Retry-After", fmt.Sprint(response.Headers.RetryAfter))
	w.WriteHeader(429)
	return nil
}

type UpdateKey500JSONResponse struct{ N500JSONResponse }

func (response UpdateKey500JSONResponse) VisitUpdateKeyResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type ImportKeyMaterialRequestObject struct {
	KeyID KeyIDPath `json:"keyID"`
	Body  *ImportKeyMaterialJSONRequestBody
}

type ImportKeyMaterialResponseObject interface {
	VisitImportKeyMaterialResponse(w http.ResponseWriter) error
}

type ImportKeyMaterial201JSONResponse Key

func (response ImportKeyMaterial201JSONResponse) VisitImportKeyMaterialResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(201)

	return json.NewEncoder(w).Encode(response)
}

type ImportKeyMaterial400JSONResponse struct{ N400JSONResponse }

func (response ImportKeyMaterial400JSONResponse) VisitImportKeyMaterialResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type ImportKeyMaterial403JSONResponse struct{ N403JSONResponse }

func (response ImportKeyMaterial403JSONResponse) VisitImportKeyMaterialResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type ImportKeyMaterial404JSONResponse struct{ N404JSONResponse }

func (response ImportKeyMaterial404JSONResponse) VisitImportKeyMaterialResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type ImportKeyMaterial429Response = N429Response

func (response ImportKeyMaterial429Response) VisitImportKeyMaterialResponse(w http.ResponseWriter) error {
	w.Header().Set("Retry-After", fmt.Sprint(response.Headers.RetryAfter))
	w.WriteHeader(429)
	return nil
}

type ImportKeyMaterial500JSONResponse struct{ N500JSONResponse }

func (response ImportKeyMaterial500JSONResponse) VisitImportKeyMaterialResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type GetKeyImportParamsRequestObject struct {
	KeyID KeyIDPath `json:"keyID"`
}

type GetKeyImportParamsResponseObject interface {
	VisitGetKeyImportParamsResponse(w http.ResponseWriter) error
}

type GetKeyImportParams200JSONResponse ImportParams

func (response GetKeyImportParams200JSONResponse) VisitGetKeyImportParamsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type GetKeyImportParams400JSONResponse struct{ N400JSONResponse }

func (response GetKeyImportParams400JSONResponse) VisitGetKeyImportParamsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type GetKeyImportParams403JSONResponse struct{ N403JSONResponse }

func (response GetKeyImportParams403JSONResponse) VisitGetKeyImportParamsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type GetKeyImportParams404JSONResponse struct{ N404JSONResponse }

func (response GetKeyImportParams404JSONResponse) VisitGetKeyImportParamsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type GetKeyImportParams429Response = N429Response

func (response GetKeyImportParams429Response) VisitGetKeyImportParamsResponse(w http.ResponseWriter) error {
	w.Header().Set("Retry-After", fmt.Sprint(response.Headers.RetryAfter))
	w.WriteHeader(429)
	return nil
}

type GetKeyImportParams500JSONResponse struct{ N500JSONResponse }

func (response GetKeyImportParams500JSONResponse) VisitGetKeyImportParamsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type GetKeyVersionsRequestObject struct {
	KeyID  KeyIDPath `json:"keyID"`
	Params GetKeyVersionsParams
}

type GetKeyVersionsResponseObject interface {
	VisitGetKeyVersionsResponse(w http.ResponseWriter) error
}

type GetKeyVersions200JSONResponse KeyVersionList

func (response GetKeyVersions200JSONResponse) VisitGetKeyVersionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type GetKeyVersions400JSONResponse struct{ N400JSONResponse }

func (response GetKeyVersions400JSONResponse) VisitGetKeyVersionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type GetKeyVersions403JSONResponse struct{ N403JSONResponse }

func (response GetKeyVersions403JSONResponse) VisitGetKeyVersionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type GetKeyVersions404JSONResponse struct{ N404JSONResponse }

func (response GetKeyVersions404JSONResponse) VisitGetKeyVersionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type GetKeyVersions429Response = N429Response

func (response GetKeyVersions429Response) VisitGetKeyVersionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Retry-After", fmt.Sprint(response.Headers.RetryAfter))
	w.WriteHeader(429)
	return nil
}

type GetKeyVersions500JSONResponse struct{ N500JSONResponse }

func (response GetKeyVersions500JSONResponse) VisitGetKeyVersionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type CreateKeyVersionRequestObject struct {
	KeyID KeyIDPath `json:"keyID"`
	Body  *CreateKeyVersionJSONRequestBody
}

type CreateKeyVersionResponseObject interface {
	VisitCreateKeyVersionResponse(w http.ResponseWriter) error
}

type CreateKeyVersion201JSONResponse KeyVersion

func (response CreateKeyVersion201JSONResponse) VisitCreateKeyVersionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(201)

	return json.NewEncoder(w).Encode(response)
}

type CreateKeyVersion400JSONResponse struct{ N400JSONResponse }

func (response CreateKeyVersion400JSONResponse) VisitCreateKeyVersionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type CreateKeyVersion403JSONResponse struct{ N403JSONResponse }

func (response CreateKeyVersion403JSONResponse) VisitCreateKeyVersionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type CreateKeyVersion404JSONResponse struct{ N404JSONResponse }

func (response CreateKeyVersion404JSONResponse) VisitCreateKeyVersionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type CreateKeyVersion429Response = N429Response

func (response CreateKeyVersion429Response) VisitCreateKeyVersionResponse(w http.ResponseWriter) error {
	w.Header().Set("Retry-After", fmt.Sprint(response.Headers.RetryAfter))
	w.WriteHeader(429)
	return nil
}

type CreateKeyVersion500JSONResponse struct{ N500JSONResponse }

func (response CreateKeyVersion500JSONResponse) VisitCreateKeyVersionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type GetKeyVersionByNumberRequestObject struct {
	KeyID   KeyIDPath            `json:"keyID"`
	Version KeyVersionNumberPath `json:"version"`
}

type GetKeyVersionByNumberResponseObject interface {
	VisitGetKeyVersionByNumberResponse(w http.ResponseWriter) error
}

type GetKeyVersionByNumber200JSONResponse KeyVersion

func (response GetKeyVersionByNumber200JSONResponse) VisitGetKeyVersionByNumberResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type GetKeyVersionByNumber400JSONResponse struct{ N400JSONResponse }

func (response GetKeyVersionByNumber400JSONResponse) VisitGetKeyVersionByNumberResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type GetKeyVersionByNumber403JSONResponse struct{ N403JSONResponse }

func (response GetKeyVersionByNumber403JSONResponse) VisitGetKeyVersionByNumberResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type GetKeyVersionByNumber404JSONResponse struct{ N404JSONResponse }

func (response GetKeyVersionByNumber404JSONResponse) VisitGetKeyVersionByNumberResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type GetKeyVersionByNumber429Response = N429Response

func (response GetKeyVersionByNumber429Response) VisitGetKeyVersionByNumberResponse(w http.ResponseWriter) error {
	w.Header().Set("Retry-After", fmt.Sprint(response.Headers.RetryAfter))
	w.WriteHeader(429)
	return nil
}

type GetKeyVersionByNumber500JSONResponse struct{ N500JSONResponse }

func (response GetKeyVersionByNumber500JSONResponse) VisitGetKeyVersionByNumberResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type GetAllSystemsRequestObject struct {
	Params GetAllSystemsParams
}

type GetAllSystemsResponseObject interface {
	VisitGetAllSystemsResponse(w http.ResponseWriter) error
}

type GetAllSystems200JSONResponse SystemList

func (response GetAllSystems200JSONResponse) VisitGetAllSystemsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type GetAllSystems400JSONResponse struct{ N400JSONResponse }

func (response GetAllSystems400JSONResponse) VisitGetAllSystemsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type GetAllSystems403JSONResponse struct{ N403JSONResponse }

func (response GetAllSystems403JSONResponse) VisitGetAllSystemsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type GetAllSystems429Response = N429Response

func (response GetAllSystems429Response) VisitGetAllSystemsResponse(w http.ResponseWriter) error {
	w.Header().Set("Retry-After", fmt.Sprint(response.Headers.RetryAfter))
	w.WriteHeader(429)
	return nil
}

type GetAllSystems500JSONResponse struct{ N500JSONResponse }

func (response GetAllSystems500JSONResponse) VisitGetAllSystemsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type GetSystemByIDRequestObject struct {
	SystemID SystemIDPath `json:"systemID"`
}

type GetSystemByIDResponseObject interface {
	VisitGetSystemByIDResponse(w http.ResponseWriter) error
}

type GetSystemByID200JSONResponse System

func (response GetSystemByID200JSONResponse) VisitGetSystemByIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type GetSystemByID400JSONResponse struct{ N400JSONResponse }

func (response GetSystemByID400JSONResponse) VisitGetSystemByIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type GetSystemByID403JSONResponse struct{ N403JSONResponse }

func (response GetSystemByID403JSONResponse) VisitGetSystemByIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type GetSystemByID404JSONResponse struct{ N404JSONResponse }

func (response GetSystemByID404JSONResponse) VisitGetSystemByIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type GetSystemByID429Response = N429Response

func (response GetSystemByID429Response) VisitGetSystemByIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Retry-After", fmt.Sprint(response.Headers.RetryAfter))
	w.WriteHeader(429)
	return nil
}

type GetSystemByID500JSONResponse struct{ N500JSONResponse }

func (response GetSystemByID500JSONResponse) VisitGetSystemByIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type UnlinkSystemActionRequestObject struct {
	SystemID SystemIDPath `json:"systemID"`
}

type UnlinkSystemActionResponseObject interface {
	VisitUnlinkSystemActionResponse(w http.ResponseWriter) error
}

type UnlinkSystemAction204Response struct {
}

func (response UnlinkSystemAction204Response) VisitUnlinkSystemActionResponse(w http.ResponseWriter) error {
	w.WriteHeader(204)
	return nil
}

type UnlinkSystemAction400JSONResponse struct{ N400JSONResponse }

func (response UnlinkSystemAction400JSONResponse) VisitUnlinkSystemActionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type UnlinkSystemAction403JSONResponse struct{ N403JSONResponse }

func (response UnlinkSystemAction403JSONResponse) VisitUnlinkSystemActionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type UnlinkSystemAction404JSONResponse struct{ N404JSONResponse }

func (response UnlinkSystemAction404JSONResponse) VisitUnlinkSystemActionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type UnlinkSystemAction429Response = N429Response

func (response UnlinkSystemAction429Response) VisitUnlinkSystemActionResponse(w http.ResponseWriter) error {
	w.Header().Set("Retry-After", fmt.Sprint(response.Headers.RetryAfter))
	w.WriteHeader(429)
	return nil
}

type UnlinkSystemAction500JSONResponse struct{ N500JSONResponse }

func (response UnlinkSystemAction500JSONResponse) VisitUnlinkSystemActionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type LinkSystemActionRequestObject struct {
	SystemID SystemIDPath `json:"systemID"`
	Body     *LinkSystemActionApplicationMergePatchPlusJSONRequestBody
}

type LinkSystemActionResponseObject interface {
	VisitLinkSystemActionResponse(w http.ResponseWriter) error
}

type LinkSystemAction200JSONResponse System

func (response LinkSystemAction200JSONResponse) VisitLinkSystemActionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type LinkSystemAction400JSONResponse struct{ N400JSONResponse }

func (response LinkSystemAction400JSONResponse) VisitLinkSystemActionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type LinkSystemAction403JSONResponse struct{ N403JSONResponse }

func (response LinkSystemAction403JSONResponse) VisitLinkSystemActionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type LinkSystemAction409JSONResponse struct{ N409JSONResponse }

func (response LinkSystemAction409JSONResponse) VisitLinkSystemActionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(409)

	return json.NewEncoder(w).Encode(response)
}

type LinkSystemAction429Response = N429Response

func (response LinkSystemAction429Response) VisitLinkSystemActionResponse(w http.ResponseWriter) error {
	w.Header().Set("Retry-After", fmt.Sprint(response.Headers.RetryAfter))
	w.WriteHeader(429)
	return nil
}

type LinkSystemAction500JSONResponse struct{ N500JSONResponse }

func (response LinkSystemAction500JSONResponse) VisitLinkSystemActionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type GetRecoveryActionsRequestObject struct {
	SystemID SystemIDPath `json:"systemID"`
}

type GetRecoveryActionsResponseObject interface {
	VisitGetRecoveryActionsResponse(w http.ResponseWriter) error
}

type GetRecoveryActions200JSONResponse SystemRecoveryAction

func (response GetRecoveryActions200JSONResponse) VisitGetRecoveryActionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type GetRecoveryActions400JSONResponse struct{ N400JSONResponse }

func (response GetRecoveryActions400JSONResponse) VisitGetRecoveryActionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type GetRecoveryActions403JSONResponse struct{ N403JSONResponse }

func (response GetRecoveryActions403JSONResponse) VisitGetRecoveryActionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type GetRecoveryActions409JSONResponse struct{ N409JSONResponse }

func (response GetRecoveryActions409JSONResponse) VisitGetRecoveryActionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(409)

	return json.NewEncoder(w).Encode(response)
}

type GetRecoveryActions429Response = N429Response

func (response GetRecoveryActions429Response) VisitGetRecoveryActionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Retry-After", fmt.Sprint(response.Headers.RetryAfter))
	w.WriteHeader(429)
	return nil
}

type GetRecoveryActions500JSONResponse struct{ N500JSONResponse }

func (response GetRecoveryActions500JSONResponse) VisitGetRecoveryActionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type SendRecoveryActionsRequestObject struct {
	SystemID SystemIDPath `json:"systemID"`
	Body     *SendRecoveryActionsJSONRequestBody
}

type SendRecoveryActionsResponseObject interface {
	VisitSendRecoveryActionsResponse(w http.ResponseWriter) error
}

type SendRecoveryActions200Response struct {
}

func (response SendRecoveryActions200Response) VisitSendRecoveryActionsResponse(w http.ResponseWriter) error {
	w.WriteHeader(200)
	return nil
}

type SendRecoveryActions400JSONResponse struct{ N400JSONResponse }

func (response SendRecoveryActions400JSONResponse) VisitSendRecoveryActionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type SendRecoveryActions403JSONResponse struct{ N403JSONResponse }

func (response SendRecoveryActions403JSONResponse) VisitSendRecoveryActionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type SendRecoveryActions409JSONResponse struct{ N409JSONResponse }

func (response SendRecoveryActions409JSONResponse) VisitSendRecoveryActionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(409)

	return json.NewEncoder(w).Encode(response)
}

type SendRecoveryActions429Response = N429Response

func (response SendRecoveryActions429Response) VisitSendRecoveryActionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Retry-After", fmt.Sprint(response.Headers.RetryAfter))
	w.WriteHeader(429)
	return nil
}

type SendRecoveryActions500JSONResponse struct{ N500JSONResponse }

func (response SendRecoveryActions500JSONResponse) VisitSendRecoveryActionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type GetTenantKeystoresRequestObject struct {
}

type GetTenantKeystoresResponseObject interface {
	VisitGetTenantKeystoresResponse(w http.ResponseWriter) error
}

type GetTenantKeystores200JSONResponse TenantKeystore

func (response GetTenantKeystores200JSONResponse) VisitGetTenantKeystoresResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type GetTenantKeystores400JSONResponse struct{ N400JSONResponse }

func (response GetTenantKeystores400JSONResponse) VisitGetTenantKeystoresResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type GetTenantKeystores403JSONResponse struct{ N403JSONResponse }

func (response GetTenantKeystores403JSONResponse) VisitGetTenantKeystoresResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type GetTenantKeystores429Response = N429Response

func (response GetTenantKeystores429Response) VisitGetTenantKeystoresResponse(w http.ResponseWriter) error {
	w.Header().Set("Retry-After", fmt.Sprint(response.Headers.RetryAfter))
	w.WriteHeader(429)
	return nil
}

type GetTenantKeystores500JSONResponse struct{ N500JSONResponse }

func (response GetTenantKeystores500JSONResponse) VisitGetTenantKeystoresResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type GetTenantWorkflowConfigurationRequestObject struct {
}

type GetTenantWorkflowConfigurationResponseObject interface {
	VisitGetTenantWorkflowConfigurationResponse(w http.ResponseWriter) error
}

type GetTenantWorkflowConfiguration200JSONResponse TenantWorkflowConfiguration

func (response GetTenantWorkflowConfiguration200JSONResponse) VisitGetTenantWorkflowConfigurationResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type GetTenantWorkflowConfiguration400JSONResponse struct{ N400JSONResponse }

func (response GetTenantWorkflowConfiguration400JSONResponse) VisitGetTenantWorkflowConfigurationResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type GetTenantWorkflowConfiguration403JSONResponse struct{ N403JSONResponse }

func (response GetTenantWorkflowConfiguration403JSONResponse) VisitGetTenantWorkflowConfigurationResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type GetTenantWorkflowConfiguration429Response = N429Response

func (response GetTenantWorkflowConfiguration429Response) VisitGetTenantWorkflowConfigurationResponse(w http.ResponseWriter) error {
	w.Header().Set("Retry-After", fmt.Sprint(response.Headers.RetryAfter))
	w.WriteHeader(429)
	return nil
}

type GetTenantWorkflowConfiguration500JSONResponse struct{ N500JSONResponse }

func (response GetTenantWorkflowConfiguration500JSONResponse) VisitGetTenantWorkflowConfigurationResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type UpdateTenantWorkflowConfigurationRequestObject struct {
	Body *UpdateTenantWorkflowConfigurationApplicationMergePatchPlusJSONRequestBody
}

type UpdateTenantWorkflowConfigurationResponseObject interface {
	VisitUpdateTenantWorkflowConfigurationResponse(w http.ResponseWriter) error
}

type UpdateTenantWorkflowConfiguration200JSONResponse TenantWorkflowConfiguration

func (response UpdateTenantWorkflowConfiguration200JSONResponse) VisitUpdateTenantWorkflowConfigurationResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type UpdateTenantWorkflowConfiguration400JSONResponse struct{ N400JSONResponse }

func (response UpdateTenantWorkflowConfiguration400JSONResponse) VisitUpdateTenantWorkflowConfigurationResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type UpdateTenantWorkflowConfiguration403JSONResponse struct{ N403JSONResponse }

func (response UpdateTenantWorkflowConfiguration403JSONResponse) VisitUpdateTenantWorkflowConfigurationResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type UpdateTenantWorkflowConfiguration404JSONResponse struct{ N404JSONResponse }

func (response UpdateTenantWorkflowConfiguration404JSONResponse) VisitUpdateTenantWorkflowConfigurationResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type UpdateTenantWorkflowConfiguration409JSONResponse struct{ N409JSONResponse }

func (response UpdateTenantWorkflowConfiguration409JSONResponse) VisitUpdateTenantWorkflowConfigurationResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(409)

	return json.NewEncoder(w).Encode(response)
}

type UpdateTenantWorkflowConfiguration429Response = N429Response

func (response UpdateTenantWorkflowConfiguration429Response) VisitUpdateTenantWorkflowConfigurationResponse(w http.ResponseWriter) error {
	w.Header().Set("Retry-After", fmt.Sprint(response.Headers.RetryAfter))
	w.WriteHeader(429)
	return nil
}

type UpdateTenantWorkflowConfiguration500JSONResponse struct{ N500JSONResponse }

func (response UpdateTenantWorkflowConfiguration500JSONResponse) VisitUpdateTenantWorkflowConfigurationResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type GetTenantInfoRequestObject struct {
}

type GetTenantInfoResponseObject interface {
	VisitGetTenantInfoResponse(w http.ResponseWriter) error
}

type GetTenantInfo200JSONResponse Tenant

func (response GetTenantInfo200JSONResponse) VisitGetTenantInfoResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type GetTenantInfo400JSONResponse struct{ N400JSONResponse }

func (response GetTenantInfo400JSONResponse) VisitGetTenantInfoResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type GetTenantInfo403JSONResponse struct{ N403JSONResponse }

func (response GetTenantInfo403JSONResponse) VisitGetTenantInfoResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type GetTenantInfo404JSONResponse struct{ N404JSONResponse }

func (response GetTenantInfo404JSONResponse) VisitGetTenantInfoResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type GetTenantInfo429Response = N429Response

func (response GetTenantInfo429Response) VisitGetTenantInfoResponse(w http.ResponseWriter) error {
	w.Header().Set("Retry-After", fmt.Sprint(response.Headers.RetryAfter))
	w.WriteHeader(429)
	return nil
}

type GetTenantInfo500JSONResponse struct{ N500JSONResponse }

func (response GetTenantInfo500JSONResponse) VisitGetTenantInfoResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type GetTenantsRequestObject struct {
	Params GetTenantsParams
}

type GetTenantsResponseObject interface {
	VisitGetTenantsResponse(w http.ResponseWriter) error
}

type GetTenants200JSONResponse TenantList

func (response GetTenants200JSONResponse) VisitGetTenantsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type GetTenants400JSONResponse struct{ N400JSONResponse }

func (response GetTenants400JSONResponse) VisitGetTenantsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type GetTenants403JSONResponse struct{ N403JSONResponse }

func (response GetTenants403JSONResponse) VisitGetTenantsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type GetTenants429Response = N429Response

func (response GetTenants429Response) VisitGetTenantsResponse(w http.ResponseWriter) error {
	w.Header().Set("Retry-After", fmt.Sprint(response.Headers.RetryAfter))
	w.WriteHeader(429)
	return nil
}

type GetTenants500JSONResponse struct{ N500JSONResponse }

func (response GetTenants500JSONResponse) VisitGetTenantsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type GetUserInfoRequestObject struct {
}

type GetUserInfoResponseObject interface {
	VisitGetUserInfoResponse(w http.ResponseWriter) error
}

type GetUserInfo200JSONResponse UserInfo

func (response GetUserInfo200JSONResponse) VisitGetUserInfoResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type GetUserInfo404JSONResponse struct{ N404JSONResponse }

func (response GetUserInfo404JSONResponse) VisitGetUserInfoResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type GetUserInfo429Response = N429Response

func (response GetUserInfo429Response) VisitGetUserInfoResponse(w http.ResponseWriter) error {
	w.Header().Set("Retry-After", fmt.Sprint(response.Headers.RetryAfter))
	w.WriteHeader(429)
	return nil
}

type GetUserInfo500JSONResponse struct{ N500JSONResponse }

func (response GetUserInfo500JSONResponse) VisitGetUserInfoResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type GetWorkflowsRequestObject struct {
	Params GetWorkflowsParams
}

type GetWorkflowsResponseObject interface {
	VisitGetWorkflowsResponse(w http.ResponseWriter) error
}

type GetWorkflows200JSONResponse WorkflowList

func (response GetWorkflows200JSONResponse) VisitGetWorkflowsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type GetWorkflows400JSONResponse struct{ N400JSONResponse }

func (response GetWorkflows400JSONResponse) VisitGetWorkflowsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type GetWorkflows403JSONResponse struct{ N403JSONResponse }

func (response GetWorkflows403JSONResponse) VisitGetWorkflowsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type GetWorkflows429Response = N429Response

func (response GetWorkflows429Response) VisitGetWorkflowsResponse(w http.ResponseWriter) error {
	w.Header().Set("Retry-After", fmt.Sprint(response.Headers.RetryAfter))
	w.WriteHeader(429)
	return nil
}

type GetWorkflows500JSONResponse struct{ N500JSONResponse }

func (response GetWorkflows500JSONResponse) VisitGetWorkflowsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type CreateWorkflowRequestObject struct {
	Body *CreateWorkflowJSONRequestBody
}

type CreateWorkflowResponseObject interface {
	VisitCreateWorkflowResponse(w http.ResponseWriter) error
}

type CreateWorkflow201JSONResponse Workflow

func (response CreateWorkflow201JSONResponse) VisitCreateWorkflowResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(201)

	return json.NewEncoder(w).Encode(response)
}

type CreateWorkflow400JSONResponse struct{ N400JSONResponse }

func (response CreateWorkflow400JSONResponse) VisitCreateWorkflowResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type CreateWorkflow403JSONResponse struct{ N403JSONResponse }

func (response CreateWorkflow403JSONResponse) VisitCreateWorkflowResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type CreateWorkflow404JSONResponse struct{ N404JSONResponse }

func (response CreateWorkflow404JSONResponse) VisitCreateWorkflowResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type CreateWorkflow409JSONResponse struct{ N409JSONResponse }

func (response CreateWorkflow409JSONResponse) VisitCreateWorkflowResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(409)

	return json.NewEncoder(w).Encode(response)
}

type CreateWorkflow429Response = N429Response

func (response CreateWorkflow429Response) VisitCreateWorkflowResponse(w http.ResponseWriter) error {
	w.Header().Set("Retry-After", fmt.Sprint(response.Headers.RetryAfter))
	w.WriteHeader(429)
	return nil
}

type CreateWorkflow500JSONResponse struct{ N500JSONResponse }

func (response CreateWorkflow500JSONResponse) VisitCreateWorkflowResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type CheckWorkflowRequestObject struct {
	Body *CheckWorkflowJSONRequestBody
}

type CheckWorkflowResponseObject interface {
	VisitCheckWorkflowResponse(w http.ResponseWriter) error
}

type CheckWorkflow200JSONResponse WorkflowCheck

func (response CheckWorkflow200JSONResponse) VisitCheckWorkflowResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type CheckWorkflow400JSONResponse struct{ N400JSONResponse }

func (response CheckWorkflow400JSONResponse) VisitCheckWorkflowResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type CheckWorkflow403JSONResponse struct{ N403JSONResponse }

func (response CheckWorkflow403JSONResponse) VisitCheckWorkflowResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type CheckWorkflow404JSONResponse struct{ N404JSONResponse }

func (response CheckWorkflow404JSONResponse) VisitCheckWorkflowResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type CheckWorkflow409JSONResponse struct{ N409JSONResponse }

func (response CheckWorkflow409JSONResponse) VisitCheckWorkflowResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(409)

	return json.NewEncoder(w).Encode(response)
}

type CheckWorkflow429Response = N429Response

func (response CheckWorkflow429Response) VisitCheckWorkflowResponse(w http.ResponseWriter) error {
	w.Header().Set("Retry-After", fmt.Sprint(response.Headers.RetryAfter))
	w.WriteHeader(429)
	return nil
}

type CheckWorkflow500JSONResponse struct{ N500JSONResponse }

func (response CheckWorkflow500JSONResponse) VisitCheckWorkflowResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type GetWorkflowByIDRequestObject struct {
	WorkflowID WorkflowIDPath `json:"workflowID"`
}

type GetWorkflowByIDResponseObject interface {
	VisitGetWorkflowByIDResponse(w http.ResponseWriter) error
}

type GetWorkflowByID200JSONResponse DetailedWorkflow

func (response GetWorkflowByID200JSONResponse) VisitGetWorkflowByIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type GetWorkflowByID400JSONResponse struct{ N400JSONResponse }

func (response GetWorkflowByID400JSONResponse) VisitGetWorkflowByIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type GetWorkflowByID403JSONResponse struct{ N403JSONResponse }

func (response GetWorkflowByID403JSONResponse) VisitGetWorkflowByIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type GetWorkflowByID404JSONResponse struct{ N404JSONResponse }

func (response GetWorkflowByID404JSONResponse) VisitGetWorkflowByIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type GetWorkflowByID429Response = N429Response

func (response GetWorkflowByID429Response) VisitGetWorkflowByIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Retry-After", fmt.Sprint(response.Headers.RetryAfter))
	w.WriteHeader(429)
	return nil
}

type GetWorkflowByID500JSONResponse struct{ N500JSONResponse }

func (response GetWorkflowByID500JSONResponse) VisitGetWorkflowByIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type TransitionWorkflowRequestObject struct {
	WorkflowID WorkflowIDPath `json:"workflowID"`
	Body       *TransitionWorkflowJSONRequestBody
}

type TransitionWorkflowResponseObject interface {
	VisitTransitionWorkflowResponse(w http.ResponseWriter) error
}

type TransitionWorkflow200JSONResponse Workflow

func (response TransitionWorkflow200JSONResponse) VisitTransitionWorkflowResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type TransitionWorkflow400JSONResponse struct{ N400JSONResponse }

func (response TransitionWorkflow400JSONResponse) VisitTransitionWorkflowResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type TransitionWorkflow403JSONResponse struct{ N403JSONResponse }

func (response TransitionWorkflow403JSONResponse) VisitTransitionWorkflowResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type TransitionWorkflow404JSONResponse struct{ N404JSONResponse }

func (response TransitionWorkflow404JSONResponse) VisitTransitionWorkflowResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type TransitionWorkflow429Response = N429Response

func (response TransitionWorkflow429Response) VisitTransitionWorkflowResponse(w http.ResponseWriter) error {
	w.Header().Set("Retry-After", fmt.Sprint(response.Headers.RetryAfter))
	w.WriteHeader(429)
	return nil
}

type TransitionWorkflow500JSONResponse struct{ N500JSONResponse }

func (response TransitionWorkflow500JSONResponse) VisitTransitionWorkflowResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

// StrictServerInterface represents all server handlers.
type StrictServerInterface interface {
	// Get Groups
	// (GET /groups)
	GetGroups(ctx context.Context, request GetGroupsRequestObject) (GetGroupsResponseObject, error)
	// Create a new Group
	// (POST /groups)
	CreateGroup(ctx context.Context, request CreateGroupRequestObject) (CreateGroupResponseObject, error)
	// Check groups existence in IAM provider
	// (POST /groups/iamCheck)
	CheckGroupsIAM(ctx context.Context, request CheckGroupsIAMRequestObject) (CheckGroupsIAMResponseObject, error)
	// Delete a Group by its ID
	// (DELETE /groups/{groupID})
	DeleteGroupByID(ctx context.Context, request DeleteGroupByIDRequestObject) (DeleteGroupByIDResponseObject, error)
	// Get Group by ID
	// (GET /groups/{groupID})
	GetGroupByID(ctx context.Context, request GetGroupByIDRequestObject) (GetGroupByIDResponseObject, error)
	// Update group
	// (PATCH /groups/{groupID})
	UpdateGroup(ctx context.Context, request UpdateGroupRequestObject) (UpdateGroupResponseObject, error)
	// Delete a specified Label from a Key
	// (DELETE /key/{keyID}/label/{labelName})
	DeleteLabel(ctx context.Context, request DeleteLabelRequestObject) (DeleteLabelResponseObject, error)
	// Get the Labels associated with the Key
	// (GET /key/{keyID}/labels)
	GetKeyLabels(ctx context.Context, request GetKeyLabelsRequestObject) (GetKeyLabelsResponseObject, error)
	// Create and update Labels
	// (POST /key/{keyID}/labels)
	CreateOrUpdateLabels(ctx context.Context, request CreateOrUpdateLabelsRequestObject) (CreateOrUpdateLabelsResponseObject, error)
	// Get all Key Configurations
	// (GET /keyConfigurations)
	GetKeyConfigurations(ctx context.Context, request GetKeyConfigurationsRequestObject) (GetKeyConfigurationsResponseObject, error)
	// Create a new Key Configuration
	// (POST /keyConfigurations)
	PostKeyConfigurations(ctx context.Context, request PostKeyConfigurationsRequestObject) (PostKeyConfigurationsResponseObject, error)
	// Delete an Key Configuration by its ID
	// (DELETE /keyConfigurations/{keyConfigurationID})
	DeleteKeyConfigurationByID(ctx context.Context, request DeleteKeyConfigurationByIDRequestObject) (DeleteKeyConfigurationByIDResponseObject, error)
	// Get Key Configuration metadata by ID
	// (GET /keyConfigurations/{keyConfigurationID})
	GetKeyConfigurationByID(ctx context.Context, request GetKeyConfigurationByIDRequestObject) (GetKeyConfigurationByIDResponseObject, error)
	// Update Key Configuration metadata by ID
	// (PATCH /keyConfigurations/{keyConfigurationID})
	UpdateKeyConfigurationByID(ctx context.Context, request UpdateKeyConfigurationByIDRequestObject) (UpdateKeyConfigurationByIDResponseObject, error)
	// Get the client certificate details
	// (GET /keyConfigurations/{keyConfigurationID}/certificates)
	GetKeyConfigurationsCertificates(ctx context.Context, request GetKeyConfigurationsCertificatesRequestObject) (GetKeyConfigurationsCertificatesResponseObject, error)
	// Get list of Tags for a Key Configuration
	// (GET /keyConfigurations/{keyConfigurationID}/tags)
	GetTagsForKeyConfiguration(ctx context.Context, request GetTagsForKeyConfigurationRequestObject) (GetTagsForKeyConfigurationResponseObject, error)
	// Either set new Tags or replace Tags for a Key Configuration
	// (PUT /keyConfigurations/{keyConfigurationID}/tags)
	AddTagsToKeyConfiguration(ctx context.Context, request AddTagsToKeyConfigurationRequestObject) (AddTagsToKeyConfigurationResponseObject, error)
	// Get metadata of Keys
	// (GET /keys)
	GetKeys(ctx context.Context, request GetKeysRequestObject) (GetKeysResponseObject, error)
	// Create a new Key
	// (POST /keys)
	PostKeys(ctx context.Context, request PostKeysRequestObject) (PostKeysResponseObject, error)
	// Delete an Key by its ID
	// (DELETE /keys/{keyID})
	DeleteKeysKeyID(ctx context.Context, request DeleteKeysKeyIDRequestObject) (DeleteKeysKeyIDResponseObject, error)
	// Get Key metadata by ID
	// (GET /keys/{keyID})
	GetKeysKeyID(ctx context.Context, request GetKeysKeyIDRequestObject) (GetKeysKeyIDResponseObject, error)
	// Update Key metadata by ID
	// (PATCH /keys/{keyID})
	UpdateKey(ctx context.Context, request UpdateKeyRequestObject) (UpdateKeyResponseObject, error)
	// Import a key material
	// (POST /keys/{keyID}/importKeyMaterial)
	ImportKeyMaterial(ctx context.Context, request ImportKeyMaterialRequestObject) (ImportKeyMaterialResponseObject, error)
	// Get import parameters for a Bring Your Own Key (BYOK) key
	// (GET /keys/{keyID}/importParams)
	GetKeyImportParams(ctx context.Context, request GetKeyImportParamsRequestObject) (GetKeyImportParamsResponseObject, error)
	// Get metadata of all Key Versions by Key ID
	// (GET /keys/{keyID}/versions)
	GetKeyVersions(ctx context.Context, request GetKeyVersionsRequestObject) (GetKeyVersionsResponseObject, error)
	// Create a new Key Version
	// (POST /keys/{keyID}/versions)
	CreateKeyVersion(ctx context.Context, request CreateKeyVersionRequestObject) (CreateKeyVersionResponseObject, error)
	// Get metadata of a key Version by key ID and Version number
	// (GET /keys/{keyID}/versions/{version})
	GetKeyVersionByNumber(ctx context.Context, request GetKeyVersionByNumberRequestObject) (GetKeyVersionByNumberResponseObject, error)
	// Retrieve all Systems
	// (GET /systems)
	GetAllSystems(ctx context.Context, request GetAllSystemsRequestObject) (GetAllSystemsResponseObject, error)
	// Retrieve a System
	// (GET /systems/{systemID})
	GetSystemByID(ctx context.Context, request GetSystemByIDRequestObject) (GetSystemByIDResponseObject, error)
	// Delete a System link
	// (DELETE /systems/{systemID}/link)
	UnlinkSystemAction(ctx context.Context, request UnlinkSystemActionRequestObject) (UnlinkSystemActionResponseObject, error)
	// Update a System link
	// (PATCH /systems/{systemID}/link)
	LinkSystemAction(ctx context.Context, request LinkSystemActionRequestObject) (LinkSystemActionResponseObject, error)
	// Possible recovery action
	// (GET /systems/{systemID}/recoveryActions)
	GetRecoveryActions(ctx context.Context, request GetRecoveryActionsRequestObject) (GetRecoveryActionsResponseObject, error)
	// Recovery action
	// (POST /systems/{systemID}/recoveryActions)
	SendRecoveryActions(ctx context.Context, request SendRecoveryActionsRequestObject) (SendRecoveryActionsResponseObject, error)
	// Get tenant keystores
	// (GET /tenantConfigurations/keystores)
	GetTenantKeystores(ctx context.Context, request GetTenantKeystoresRequestObject) (GetTenantKeystoresResponseObject, error)
	// Get tenant workflow configuration
	// (GET /tenantConfigurations/workflow)
	GetTenantWorkflowConfiguration(ctx context.Context, request GetTenantWorkflowConfigurationRequestObject) (GetTenantWorkflowConfigurationResponseObject, error)
	// Update tenant workflow configuration
	// (PATCH /tenantConfigurations/workflow)
	UpdateTenantWorkflowConfiguration(ctx context.Context, request UpdateTenantWorkflowConfigurationRequestObject) (UpdateTenantWorkflowConfigurationResponseObject, error)
	// Get tenant information
	// (GET /tenantInfo)
	GetTenantInfo(ctx context.Context, request GetTenantInfoRequestObject) (GetTenantInfoResponseObject, error)
	// Get tenants with same issuer
	// (GET /tenants)
	GetTenants(ctx context.Context, request GetTenantsRequestObject) (GetTenantsResponseObject, error)
	// Get user information
	// (GET /userInfo)
	GetUserInfo(ctx context.Context, request GetUserInfoRequestObject) (GetUserInfoResponseObject, error)
	// Get all Workflows
	// (GET /workflows)
	GetWorkflows(ctx context.Context, request GetWorkflowsRequestObject) (GetWorkflowsResponseObject, error)
	// Create a new Workflow
	// (POST /workflows)
	CreateWorkflow(ctx context.Context, request CreateWorkflowRequestObject) (CreateWorkflowResponseObject, error)
	// Check if workflow is required
	// (POST /workflows/check)
	CheckWorkflow(ctx context.Context, request CheckWorkflowRequestObject) (CheckWorkflowResponseObject, error)
	// Get a Workflow
	// (GET /workflows/{workflowID})
	GetWorkflowByID(ctx context.Context, request GetWorkflowByIDRequestObject) (GetWorkflowByIDResponseObject, error)
	// Trigger transition for a Workflow
	// (POST /workflows/{workflowID}/state)
	TransitionWorkflow(ctx context.Context, request TransitionWorkflowRequestObject) (TransitionWorkflowResponseObject, error)
}

type StrictHandlerFunc = strictnethttp.StrictHTTPHandlerFunc
type StrictMiddlewareFunc = strictnethttp.StrictHTTPMiddlewareFunc

type StrictHTTPServerOptions struct {
	RequestErrorHandlerFunc  func(w http.ResponseWriter, r *http.Request, err error)
	ResponseErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

func NewStrictHandler(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc) ServerInterface {
	return &strictHandler{ssi: ssi, middlewares: middlewares, options: StrictHTTPServerOptions{
		RequestErrorHandlerFunc: func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		},
		ResponseErrorHandlerFunc: func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusInternalServerError)
		},
	}}
}

func NewStrictHandlerWithOptions(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc, options StrictHTTPServerOptions) ServerInterface {
	return &strictHandler{ssi: ssi, middlewares: middlewares, options: options}
}

type strictHandler struct {
	ssi         StrictServerInterface
	middlewares []StrictMiddlewareFunc
	options     StrictHTTPServerOptions
}

// GetGroups operation middleware
func (sh *strictHandler) GetGroups(w http.ResponseWriter, r *http.Request, params GetGroupsParams) {
	var request GetGroupsRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetGroups(ctx, request.(GetGroupsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetGroups")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetGroupsResponseObject); ok {
		if err := validResponse.VisitGetGroupsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// CreateGroup operation middleware
func (sh *strictHandler) CreateGroup(w http.ResponseWriter, r *http.Request) {
	var request CreateGroupRequestObject

	var body CreateGroupJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.CreateGroup(ctx, request.(CreateGroupRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "CreateGroup")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(CreateGroupResponseObject); ok {
		if err := validResponse.VisitCreateGroupResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// CheckGroupsIAM operation middleware
func (sh *strictHandler) CheckGroupsIAM(w http.ResponseWriter, r *http.Request) {
	var request CheckGroupsIAMRequestObject

	var body CheckGroupsIAMJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.CheckGroupsIAM(ctx, request.(CheckGroupsIAMRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "CheckGroupsIAM")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(CheckGroupsIAMResponseObject); ok {
		if err := validResponse.VisitCheckGroupsIAMResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// DeleteGroupByID operation middleware
func (sh *strictHandler) DeleteGroupByID(w http.ResponseWriter, r *http.Request, groupID GroupIDPath) {
	var request DeleteGroupByIDRequestObject

	request.GroupID = groupID

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.DeleteGroupByID(ctx, request.(DeleteGroupByIDRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "DeleteGroupByID")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(DeleteGroupByIDResponseObject); ok {
		if err := validResponse.VisitDeleteGroupByIDResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetGroupByID operation middleware
func (sh *strictHandler) GetGroupByID(w http.ResponseWriter, r *http.Request, groupID GroupIDPath) {
	var request GetGroupByIDRequestObject

	request.GroupID = groupID

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetGroupByID(ctx, request.(GetGroupByIDRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetGroupByID")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetGroupByIDResponseObject); ok {
		if err := validResponse.VisitGetGroupByIDResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// UpdateGroup operation middleware
func (sh *strictHandler) UpdateGroup(w http.ResponseWriter, r *http.Request, groupID GroupIDPath) {
	var request UpdateGroupRequestObject

	request.GroupID = groupID

	var body UpdateGroupApplicationMergePatchPlusJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.UpdateGroup(ctx, request.(UpdateGroupRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "UpdateGroup")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(UpdateGroupResponseObject); ok {
		if err := validResponse.VisitUpdateGroupResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// DeleteLabel operation middleware
func (sh *strictHandler) DeleteLabel(w http.ResponseWriter, r *http.Request, keyID KeyIDPath, labelName string) {
	var request DeleteLabelRequestObject

	request.KeyID = keyID
	request.LabelName = labelName

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.DeleteLabel(ctx, request.(DeleteLabelRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "DeleteLabel")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(DeleteLabelResponseObject); ok {
		if err := validResponse.VisitDeleteLabelResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetKeyLabels operation middleware
func (sh *strictHandler) GetKeyLabels(w http.ResponseWriter, r *http.Request, keyID KeyIDPath, params GetKeyLabelsParams) {
	var request GetKeyLabelsRequestObject

	request.KeyID = keyID
	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetKeyLabels(ctx, request.(GetKeyLabelsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetKeyLabels")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetKeyLabelsResponseObject); ok {
		if err := validResponse.VisitGetKeyLabelsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// CreateOrUpdateLabels operation middleware
func (sh *strictHandler) CreateOrUpdateLabels(w http.ResponseWriter, r *http.Request, keyID KeyIDPath) {
	var request CreateOrUpdateLabelsRequestObject

	request.KeyID = keyID

	var body CreateOrUpdateLabelsJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.CreateOrUpdateLabels(ctx, request.(CreateOrUpdateLabelsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "CreateOrUpdateLabels")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(CreateOrUpdateLabelsResponseObject); ok {
		if err := validResponse.VisitCreateOrUpdateLabelsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetKeyConfigurations operation middleware
func (sh *strictHandler) GetKeyConfigurations(w http.ResponseWriter, r *http.Request, params GetKeyConfigurationsParams) {
	var request GetKeyConfigurationsRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetKeyConfigurations(ctx, request.(GetKeyConfigurationsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetKeyConfigurations")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetKeyConfigurationsResponseObject); ok {
		if err := validResponse.VisitGetKeyConfigurationsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// PostKeyConfigurations operation middleware
func (sh *strictHandler) PostKeyConfigurations(w http.ResponseWriter, r *http.Request) {
	var request PostKeyConfigurationsRequestObject

	var body PostKeyConfigurationsJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PostKeyConfigurations(ctx, request.(PostKeyConfigurationsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PostKeyConfigurations")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PostKeyConfigurationsResponseObject); ok {
		if err := validResponse.VisitPostKeyConfigurationsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// DeleteKeyConfigurationByID operation middleware
func (sh *strictHandler) DeleteKeyConfigurationByID(w http.ResponseWriter, r *http.Request, keyConfigurationID KeyConfigurationIDPath) {
	var request DeleteKeyConfigurationByIDRequestObject

	request.KeyConfigurationID = keyConfigurationID

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.DeleteKeyConfigurationByID(ctx, request.(DeleteKeyConfigurationByIDRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "DeleteKeyConfigurationByID")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(DeleteKeyConfigurationByIDResponseObject); ok {
		if err := validResponse.VisitDeleteKeyConfigurationByIDResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetKeyConfigurationByID operation middleware
func (sh *strictHandler) GetKeyConfigurationByID(w http.ResponseWriter, r *http.Request, keyConfigurationID KeyConfigurationIDPath) {
	var request GetKeyConfigurationByIDRequestObject

	request.KeyConfigurationID = keyConfigurationID

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetKeyConfigurationByID(ctx, request.(GetKeyConfigurationByIDRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetKeyConfigurationByID")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetKeyConfigurationByIDResponseObject); ok {
		if err := validResponse.VisitGetKeyConfigurationByIDResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// UpdateKeyConfigurationByID operation middleware
func (sh *strictHandler) UpdateKeyConfigurationByID(w http.ResponseWriter, r *http.Request, keyConfigurationID KeyConfigurationIDPath) {
	var request UpdateKeyConfigurationByIDRequestObject

	request.KeyConfigurationID = keyConfigurationID

	var body UpdateKeyConfigurationByIDApplicationMergePatchPlusJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.UpdateKeyConfigurationByID(ctx, request.(UpdateKeyConfigurationByIDRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "UpdateKeyConfigurationByID")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(UpdateKeyConfigurationByIDResponseObject); ok {
		if err := validResponse.VisitUpdateKeyConfigurationByIDResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetKeyConfigurationsCertificates operation middleware
func (sh *strictHandler) GetKeyConfigurationsCertificates(w http.ResponseWriter, r *http.Request, keyConfigurationID KeyConfigurationIDPath, params GetKeyConfigurationsCertificatesParams) {
	var request GetKeyConfigurationsCertificatesRequestObject

	request.KeyConfigurationID = keyConfigurationID
	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetKeyConfigurationsCertificates(ctx, request.(GetKeyConfigurationsCertificatesRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetKeyConfigurationsCertificates")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetKeyConfigurationsCertificatesResponseObject); ok {
		if err := validResponse.VisitGetKeyConfigurationsCertificatesResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetTagsForKeyConfiguration operation middleware
func (sh *strictHandler) GetTagsForKeyConfiguration(w http.ResponseWriter, r *http.Request, keyConfigurationID KeyConfigurationIDPath, params GetTagsForKeyConfigurationParams) {
	var request GetTagsForKeyConfigurationRequestObject

	request.KeyConfigurationID = keyConfigurationID
	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetTagsForKeyConfiguration(ctx, request.(GetTagsForKeyConfigurationRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetTagsForKeyConfiguration")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetTagsForKeyConfigurationResponseObject); ok {
		if err := validResponse.VisitGetTagsForKeyConfigurationResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// AddTagsToKeyConfiguration operation middleware
func (sh *strictHandler) AddTagsToKeyConfiguration(w http.ResponseWriter, r *http.Request, keyConfigurationID KeyConfigurationIDPath) {
	var request AddTagsToKeyConfigurationRequestObject

	request.KeyConfigurationID = keyConfigurationID

	var body AddTagsToKeyConfigurationJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.AddTagsToKeyConfiguration(ctx, request.(AddTagsToKeyConfigurationRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "AddTagsToKeyConfiguration")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(AddTagsToKeyConfigurationResponseObject); ok {
		if err := validResponse.VisitAddTagsToKeyConfigurationResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetKeys operation middleware
func (sh *strictHandler) GetKeys(w http.ResponseWriter, r *http.Request, params GetKeysParams) {
	var request GetKeysRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetKeys(ctx, request.(GetKeysRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetKeys")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetKeysResponseObject); ok {
		if err := validResponse.VisitGetKeysResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// PostKeys operation middleware
func (sh *strictHandler) PostKeys(w http.ResponseWriter, r *http.Request) {
	var request PostKeysRequestObject

	var body PostKeysJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PostKeys(ctx, request.(PostKeysRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PostKeys")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PostKeysResponseObject); ok {
		if err := validResponse.VisitPostKeysResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// DeleteKeysKeyID operation middleware
func (sh *strictHandler) DeleteKeysKeyID(w http.ResponseWriter, r *http.Request, keyID KeyIDPath) {
	var request DeleteKeysKeyIDRequestObject

	request.KeyID = keyID

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.DeleteKeysKeyID(ctx, request.(DeleteKeysKeyIDRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "DeleteKeysKeyID")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(DeleteKeysKeyIDResponseObject); ok {
		if err := validResponse.VisitDeleteKeysKeyIDResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetKeysKeyID operation middleware
func (sh *strictHandler) GetKeysKeyID(w http.ResponseWriter, r *http.Request, keyID KeyIDPath) {
	var request GetKeysKeyIDRequestObject

	request.KeyID = keyID

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetKeysKeyID(ctx, request.(GetKeysKeyIDRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetKeysKeyID")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetKeysKeyIDResponseObject); ok {
		if err := validResponse.VisitGetKeysKeyIDResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// UpdateKey operation middleware
func (sh *strictHandler) UpdateKey(w http.ResponseWriter, r *http.Request, keyID KeyIDPath) {
	var request UpdateKeyRequestObject

	request.KeyID = keyID

	var body UpdateKeyApplicationMergePatchPlusJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.UpdateKey(ctx, request.(UpdateKeyRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "UpdateKey")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(UpdateKeyResponseObject); ok {
		if err := validResponse.VisitUpdateKeyResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// ImportKeyMaterial operation middleware
func (sh *strictHandler) ImportKeyMaterial(w http.ResponseWriter, r *http.Request, keyID KeyIDPath) {
	var request ImportKeyMaterialRequestObject

	request.KeyID = keyID

	var body ImportKeyMaterialJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.ImportKeyMaterial(ctx, request.(ImportKeyMaterialRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "ImportKeyMaterial")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(ImportKeyMaterialResponseObject); ok {
		if err := validResponse.VisitImportKeyMaterialResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetKeyImportParams operation middleware
func (sh *strictHandler) GetKeyImportParams(w http.ResponseWriter, r *http.Request, keyID KeyIDPath) {
	var request GetKeyImportParamsRequestObject

	request.KeyID = keyID

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetKeyImportParams(ctx, request.(GetKeyImportParamsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetKeyImportParams")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetKeyImportParamsResponseObject); ok {
		if err := validResponse.VisitGetKeyImportParamsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetKeyVersions operation middleware
func (sh *strictHandler) GetKeyVersions(w http.ResponseWriter, r *http.Request, keyID KeyIDPath, params GetKeyVersionsParams) {
	var request GetKeyVersionsRequestObject

	request.KeyID = keyID
	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetKeyVersions(ctx, request.(GetKeyVersionsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetKeyVersions")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetKeyVersionsResponseObject); ok {
		if err := validResponse.VisitGetKeyVersionsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// CreateKeyVersion operation middleware
func (sh *strictHandler) CreateKeyVersion(w http.ResponseWriter, r *http.Request, keyID KeyIDPath) {
	var request CreateKeyVersionRequestObject

	request.KeyID = keyID

	var body CreateKeyVersionJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.CreateKeyVersion(ctx, request.(CreateKeyVersionRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "CreateKeyVersion")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(CreateKeyVersionResponseObject); ok {
		if err := validResponse.VisitCreateKeyVersionResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetKeyVersionByNumber operation middleware
func (sh *strictHandler) GetKeyVersionByNumber(w http.ResponseWriter, r *http.Request, keyID KeyIDPath, version KeyVersionNumberPath) {
	var request GetKeyVersionByNumberRequestObject

	request.KeyID = keyID
	request.Version = version

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetKeyVersionByNumber(ctx, request.(GetKeyVersionByNumberRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetKeyVersionByNumber")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetKeyVersionByNumberResponseObject); ok {
		if err := validResponse.VisitGetKeyVersionByNumberResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetAllSystems operation middleware
func (sh *strictHandler) GetAllSystems(w http.ResponseWriter, r *http.Request, params GetAllSystemsParams) {
	var request GetAllSystemsRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetAllSystems(ctx, request.(GetAllSystemsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetAllSystems")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetAllSystemsResponseObject); ok {
		if err := validResponse.VisitGetAllSystemsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetSystemByID operation middleware
func (sh *strictHandler) GetSystemByID(w http.ResponseWriter, r *http.Request, systemID SystemIDPath) {
	var request GetSystemByIDRequestObject

	request.SystemID = systemID

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetSystemByID(ctx, request.(GetSystemByIDRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetSystemByID")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetSystemByIDResponseObject); ok {
		if err := validResponse.VisitGetSystemByIDResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// UnlinkSystemAction operation middleware
func (sh *strictHandler) UnlinkSystemAction(w http.ResponseWriter, r *http.Request, systemID SystemIDPath) {
	var request UnlinkSystemActionRequestObject

	request.SystemID = systemID

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.UnlinkSystemAction(ctx, request.(UnlinkSystemActionRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "UnlinkSystemAction")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(UnlinkSystemActionResponseObject); ok {
		if err := validResponse.VisitUnlinkSystemActionResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// LinkSystemAction operation middleware
func (sh *strictHandler) LinkSystemAction(w http.ResponseWriter, r *http.Request, systemID SystemIDPath) {
	var request LinkSystemActionRequestObject

	request.SystemID = systemID

	var body LinkSystemActionApplicationMergePatchPlusJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.LinkSystemAction(ctx, request.(LinkSystemActionRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "LinkSystemAction")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(LinkSystemActionResponseObject); ok {
		if err := validResponse.VisitLinkSystemActionResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetRecoveryActions operation middleware
func (sh *strictHandler) GetRecoveryActions(w http.ResponseWriter, r *http.Request, systemID SystemIDPath) {
	var request GetRecoveryActionsRequestObject

	request.SystemID = systemID

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetRecoveryActions(ctx, request.(GetRecoveryActionsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetRecoveryActions")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetRecoveryActionsResponseObject); ok {
		if err := validResponse.VisitGetRecoveryActionsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// SendRecoveryActions operation middleware
func (sh *strictHandler) SendRecoveryActions(w http.ResponseWriter, r *http.Request, systemID SystemIDPath) {
	var request SendRecoveryActionsRequestObject

	request.SystemID = systemID

	var body SendRecoveryActionsJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.SendRecoveryActions(ctx, request.(SendRecoveryActionsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "SendRecoveryActions")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(SendRecoveryActionsResponseObject); ok {
		if err := validResponse.VisitSendRecoveryActionsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetTenantKeystores operation middleware
func (sh *strictHandler) GetTenantKeystores(w http.ResponseWriter, r *http.Request) {
	var request GetTenantKeystoresRequestObject

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetTenantKeystores(ctx, request.(GetTenantKeystoresRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetTenantKeystores")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetTenantKeystoresResponseObject); ok {
		if err := validResponse.VisitGetTenantKeystoresResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetTenantWorkflowConfiguration operation middleware
func (sh *strictHandler) GetTenantWorkflowConfiguration(w http.ResponseWriter, r *http.Request) {
	var request GetTenantWorkflowConfigurationRequestObject

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetTenantWorkflowConfiguration(ctx, request.(GetTenantWorkflowConfigurationRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetTenantWorkflowConfiguration")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetTenantWorkflowConfigurationResponseObject); ok {
		if err := validResponse.VisitGetTenantWorkflowConfigurationResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// UpdateTenantWorkflowConfiguration operation middleware
func (sh *strictHandler) UpdateTenantWorkflowConfiguration(w http.ResponseWriter, r *http.Request) {
	var request UpdateTenantWorkflowConfigurationRequestObject

	var body UpdateTenantWorkflowConfigurationApplicationMergePatchPlusJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.UpdateTenantWorkflowConfiguration(ctx, request.(UpdateTenantWorkflowConfigurationRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "UpdateTenantWorkflowConfiguration")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(UpdateTenantWorkflowConfigurationResponseObject); ok {
		if err := validResponse.VisitUpdateTenantWorkflowConfigurationResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetTenantInfo operation middleware
func (sh *strictHandler) GetTenantInfo(w http.ResponseWriter, r *http.Request) {
	var request GetTenantInfoRequestObject

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetTenantInfo(ctx, request.(GetTenantInfoRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetTenantInfo")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetTenantInfoResponseObject); ok {
		if err := validResponse.VisitGetTenantInfoResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetTenants operation middleware
func (sh *strictHandler) GetTenants(w http.ResponseWriter, r *http.Request, params GetTenantsParams) {
	var request GetTenantsRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetTenants(ctx, request.(GetTenantsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetTenants")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetTenantsResponseObject); ok {
		if err := validResponse.VisitGetTenantsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetUserInfo operation middleware
func (sh *strictHandler) GetUserInfo(w http.ResponseWriter, r *http.Request) {
	var request GetUserInfoRequestObject

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetUserInfo(ctx, request.(GetUserInfoRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetUserInfo")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetUserInfoResponseObject); ok {
		if err := validResponse.VisitGetUserInfoResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetWorkflows operation middleware
func (sh *strictHandler) GetWorkflows(w http.ResponseWriter, r *http.Request, params GetWorkflowsParams) {
	var request GetWorkflowsRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetWorkflows(ctx, request.(GetWorkflowsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetWorkflows")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetWorkflowsResponseObject); ok {
		if err := validResponse.VisitGetWorkflowsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// CreateWorkflow operation middleware
func (sh *strictHandler) CreateWorkflow(w http.ResponseWriter, r *http.Request) {
	var request CreateWorkflowRequestObject

	var body CreateWorkflowJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.CreateWorkflow(ctx, request.(CreateWorkflowRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "CreateWorkflow")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(CreateWorkflowResponseObject); ok {
		if err := validResponse.VisitCreateWorkflowResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// CheckWorkflow operation middleware
func (sh *strictHandler) CheckWorkflow(w http.ResponseWriter, r *http.Request) {
	var request CheckWorkflowRequestObject

	var body CheckWorkflowJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.CheckWorkflow(ctx, request.(CheckWorkflowRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "CheckWorkflow")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(CheckWorkflowResponseObject); ok {
		if err := validResponse.VisitCheckWorkflowResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetWorkflowByID operation middleware
func (sh *strictHandler) GetWorkflowByID(w http.ResponseWriter, r *http.Request, workflowID WorkflowIDPath) {
	var request GetWorkflowByIDRequestObject

	request.WorkflowID = workflowID

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetWorkflowByID(ctx, request.(GetWorkflowByIDRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetWorkflowByID")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetWorkflowByIDResponseObject); ok {
		if err := validResponse.VisitGetWorkflowByIDResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// TransitionWorkflow operation middleware
func (sh *strictHandler) TransitionWorkflow(w http.ResponseWriter, r *http.Request, workflowID WorkflowIDPath) {
	var request TransitionWorkflowRequestObject

	request.WorkflowID = workflowID

	var body TransitionWorkflowJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.TransitionWorkflow(ctx, request.(TransitionWorkflowRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "TransitionWorkflow")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(TransitionWorkflowResponseObject); ok {
		if err := validResponse.VisitTransitionWorkflowResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"AQA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
